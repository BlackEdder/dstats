
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dstats.alloc</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dstats.alloc");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dstats.alloc</h1><!-- Generated by Ddoc from dstats\alloc.d -->
Stuff having to do with memory management.  Mostly a copy of RegionAllocator
for now until it gets into Phobos, as well as some RegionAllocator-specific
data structures.
<br><br>
<b>Author:</b><br>
David Simcha<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">appendDelOld</span>
<script>explorer.outline.addDecl('appendDelOld');</script>

(T, U)(ref T[] <span class="funcparam">to</span>, U <span class="funcparam">from</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Appends to an array, deleting the old array if it has to be realloced.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">HashRange</span>
<script>explorer.outline.addDecl('HashRange');</script>

(K,S,bool vals = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Forward range struct for iterating over the keys or values of a
 StackHash or StackSet.  The lifetime of this object must not exceed that
 of the underlying StackHash or StackSet.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">popFront</span>
<script>explorer.outline.addDecl('popFront');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Unqual!(K) 
<span class="currsymbol">front</span>
<script>explorer.outline.addDecl('front');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">empty</span>
<script>explorer.outline.addDecl('empty');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">typeof(this) 
<span class="currsymbol">save</span>
<script>explorer.outline.addDecl('save');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">StackHash</span>
<script>explorer.outline.addDecl('StackHash');</script>

(K,V);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A hash table that allocates its memory on RegionAllocator.  Good for building a
 temporary hash tables that will not escape the current scope.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>auto</font> alloc = newRegionAllocator();
 <font color=blue>auto</font> ss = <u>StackHash</u>!(<font color=blue>uint</font>)(5, alloc);
 <font color=blue>foreach</font>(i; 0..5) {
     ss[i]++;
 }
 <font color=blue>assert</font>(ss[3] == 1);
</pre>

<br><br>
<b>Warning:</b><br>
This implementation places removed nodes on an internal free list and
 recycles them, since there is no way to delete RegionAllocator-allocated data
 in a non-LIFO order.  Therefore, you may not retain the address of a
 variable stored in a 
<span class="currsymbol">StackHash</span>
<script>explorer.outline.addDecl('StackHash');</script>

 after deleting it from the StachHash.
 For example, DO NOT do this:
<pre class="d_code"> SomeType* myPtr = &amp;(myStackHash[<font color=red>"foo"</font>]);
 myStackHash.remove(<font color=red>"foo"</font>);
 *myPtr = someValue;
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">this(size_t <span class="funcparam">nElem</span>, RegionAllocator <span class="funcparam">alloc</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Due to the nature of RegionAllocator, you must specify on object creation
 the approximate number of elements your table will have.  Too large a
 number will waste space and incur poor cache performance.  Too low a
 number will make this struct perform like a linked list.  Generally,
 if you're building a table from some other range, some fraction of the
 size of that range is a good guess.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V 
<span class="currsymbol">opIndex</span>
<script>explorer.outline.addDecl('opIndex');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Index an element of the range.  If it does not exist, it will be created
 and initialized to V.init.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V 
<span class="currsymbol">opIndexAssign</span>
<script>explorer.outline.addDecl('opIndexAssign');</script>

(V <span class="funcparam">val</span>, K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V* 
<span class="currsymbol">opIn_r</span>
<script>explorer.outline.addDecl('opIn_r');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">HashRange!(K,StackHash!(K,V)) 
<span class="currsymbol">keys</span>
<script>explorer.outline.addDecl('keys');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a forward range to iterate over the 
<span class="currsymbol">keys</span>
<script>explorer.outline.addDecl('keys');</script>

 of this table.
 The lifetime of the HashRange must not exceed the lifetime of this
 StackHash.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">HashRange!(V,StackHash!(K,V),true) 
<span class="currsymbol">values</span>
<script>explorer.outline.addDecl('values');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a forward range to iterate over the 
<span class="currsymbol">values</span>
<script>explorer.outline.addDecl('values');</script>

 of this table.
 The lifetime of the HashRange must not exceed the lifetime of this
 StackHash.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V 
<span class="currsymbol">get</span>
<script>explorer.outline.addDecl('get');</script>

(K <span class="funcparam">key</span>, lazy V <span class="funcparam">defaultValue</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Attempt to look up a <span class="funcparam">key</span> and return a default value if the <span class="funcparam">key</span> is not
    present.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">StackSet</span>
<script>explorer.outline.addDecl('StackSet');</script>

(K);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A hash set that allocates its memory on RegionAllocator.  Good for building a
 temporary set that will not escape the current scope.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>auto</font> alloc = newRegionAllocator();
 <font color=blue>auto</font> ss = <u>StackSet</u>!(<font color=blue>uint</font>)(5, alloc);
 <font color=blue>foreach</font>(i; 0..5) {
     ss.insert(i);
 }
 <font color=blue>assert</font>(3 <font color=blue>in</font> ss);
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">this(size_t <span class="funcparam">nElem</span>, RegionAllocator <span class="funcparam">alloc</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Due to the nature of RegionAllocator, you must specify on object creation
 the approximate number of elements your set will have.  Too large a
 number will waste space and incur poor cache performance.  Too low a
 number will make this struct perform like a linked list.  Generally,
 if you're building a set from some other range, some fraction of the
 size of that range is a good guess.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">insert</span>
<script>explorer.outline.addDecl('insert');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">HashRange!(K,typeof(this)) 
<span class="currsymbol">elems</span>
<script>explorer.outline.addDecl('elems');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a forward range of the elements of this struct.  The range's
 lifetime must not exceed the lifetime of this object.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">opIn_r</span>
<script>explorer.outline.addDecl('opIn_r');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">StackTree</span>
<script>explorer.outline.addDecl('StackTree');</script>

(T,alias key = "a",alias compFun = "a &lt; b");
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An AVL tree implementation on top of RegionAllocator.  If elements are removed,
 they are stored on an internal free list and recycled when new elements
 are added to the tree.
<br><br>
Template paramters:
<br><br>

 T = The type to be stored in the tree.
<br><br>

 key = Function to access the key that what you're storing is to be compared
       on.
<br><br>

 compFun = The function for comparing keys.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>struct</font> StringNum {
     string someString;
     <font color=blue>uint</font> num;
 }

 <font color=green>// Create a StackTree of StringNums, sorted in descending order, using
</font> <font color=green>// someString for comparison.
</font> <font color=blue>auto</font> alloc = newRegionAllocator();
 <font color=blue>auto</font> myTree = <u>StackTree</u>!(StringNum, <font color=red>"a.someString"</font>, <font color=red>"a &gt; b"</font>)(alloc);

 <font color=green>// Add some elements.
</font> myTree.insert( StringNum(<font color=red>"foo"</font>, 1));
 myTree.insert( StringNum(<font color=red>"bar"</font>, 2));
 myTree.insert( StringNum(<font color=red>"foo"</font>, 3));

 <font color=blue>assert</font>(myTree.find(<font color=red>"foo"</font>) == StringNum(<font color=red>"foo"</font>, 3));
 <font color=blue>assert</font>(myTree.find(<font color=red>"bar"</font>) == StringNum(<font color=red>"bar"</font>, 2));
</pre>

<br><br>
<b>Note:</b><br>
This tree supports a compile-time interface similar to StackSet
 and can be used as a finite set implementation.

<br><br>
<b>Warning:</b><br>
This implementation places removed nodes on an internal free list and
 recycles them, since there is no way to delete RegionAllocator-allocated data
 in a non-LIFO order.  Therefore, you may not retain the address of a
 variable stored in a 
<span class="currsymbol">StackTree</span>
<script>explorer.outline.addDecl('StackTree');</script>

 after deleting it from the 
<span class="currsymbol">StackTree</span>
<script>explorer.outline.addDecl('StackTree');</script>

.
 For example, DO NOT do this:
<pre class="d_code"> SomeType* myPtr = <font color=red>"foo"</font> <font color=blue>in</font> myTree;
 myTree.remove(<font color=red>"foo"</font>);
 *myPtr = someValue;
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">this(RegionAllocator <span class="funcparam">alloc</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">insert</span>
<script>explorer.outline.addDecl('insert');</script>

(T <span class="funcparam">toInsert</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Insert an element.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

(U)(U <span class="funcparam">whatToRemove</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Remove an element from this tree.  The type of U is expected to be the
 type of the key that this tree is sorted on.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T 
<span class="currsymbol">find</span>
<script>explorer.outline.addDecl('find');</script>

(U)(U <span class="funcparam">whatToFind</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Find an element and return it.  Throw an exception if it is not
 present.  U is expected to be the type of the key that this tree is
 sorted on.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T* 
<span class="currsymbol">opIn_r</span>
<script>explorer.outline.addDecl('opIn_r');</script>

(U)(U <span class="funcparam">whatToFind</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Find an element and return a pointer to it, or <b>null</b> if not present.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">opApply</span>
<script>explorer.outline.addDecl('opApply');</script>

(int delegate(ref T) <span class="funcparam">dg</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Iterate over the elements of this tree in sorted order.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow @property size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Number of elements in the tree.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">TreeAaIter</span>
<script>explorer.outline.addDecl('TreeAaIter');</script>

(T,alias mapFun);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Struct that iterates over keys or values of a StackTreeAA.
<br><br>
<font color=red>BUGS:</font><br>
Uses opApply instead of the more flexible ranges, because I
 haven't figured out how to iterate efficiently and in sorted order over a
 tree without control of the stack.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">opApply</span>
<script>explorer.outline.addDecl('opApply');</script>

(int delegate(ref IterType) <span class="funcparam">dg</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">StackTreeAA</span>
<script>explorer.outline.addDecl('StackTreeAA');</script>

(K,V);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An associative array implementation based on StackTree.  Lookups and
 insertions are O(log N).  This is significantly slower in both theory and
 practice than StackHash, but you may want to use it if:
<br><br>
1.  You don't know the approximate size of the table you will be creating
     in advance.  Unlike StackHash, this AA implementation does not need
     to pre-allocate anything.
<br><br>

 2.  You care more about worst-case performance than average-case
     performance.
<br><br>

 3.  You have a good comparison function for your type, but not a good hash
     function.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">this(RegionAllocator <span class="funcparam">alloc</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V 
<span class="currsymbol">opIndex</span>
<script>explorer.outline.addDecl('opIndex');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Looks up <span class="funcparam">key</span> in the table, returns it by reference.  If it does not
 exist, it will be created and initialized to V.init.  This is handy,
 for example, when counting things with integer types.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V 
<span class="currsymbol">opIndexAssign</span>
<script>explorer.outline.addDecl('opIndexAssign');</script>

(V <span class="funcparam">val</span>, K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V* 
<span class="currsymbol">opIn_r</span>
<script>explorer.outline.addDecl('opIn_r');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">@property TreeAaIter!(typeof(tree),"a.key") 
<span class="currsymbol">keys</span>
<script>explorer.outline.addDecl('keys');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">@property TreeAaIter!(typeof(tree),getVal) 
<span class="currsymbol">values</span>
<script>explorer.outline.addDecl('values');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">opApply</span>
<script>explorer.outline.addDecl('opApply');</script>

(int delegate(ref Unqual!(K), ref Unqual!(V)) <span class="funcparam">dg</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Iterate over both the keys and values of this associative array.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">class 
<span class="currsymbol">RegionAllocatorException</span>
<script>explorer.outline.addDecl('RegionAllocatorException');</script>

: object.Exception;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The exception that is thrown on invalid use of  and
.  This exception is not thrown on out of memory.
An  is thrown instead.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">enum 
<span class="currsymbol">GCScan</span>
<script>explorer.outline.addDecl('GCScan');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>This flag determines whether a given  is scanned for
pointers by the garbage collector (GC).  If yes, the entire stack is scanned,
not just the part currently in use, since there is currently no efficient way to
modify the bounds of a GC region.  The stack is scanned conservatively, meaning
that any bit pattern that would point to GC-allocated memory if interpreted as
a pointer is considered to be a pointer.  This can result in GC-allocated
memory being retained when it should be freed.  Due to these caveats,
it is recommended that any stack scanned by the GC be small and/or short-lived.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">
<span class="currsymbol">no</span>
<script>explorer.outline.addDecl('no');</script>

</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">
<span class="currsymbol">yes</span>
<script>explorer.outline.addDecl('yes');</script>

</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">RegionAllocatorStack</span>
<script>explorer.outline.addDecl('RegionAllocatorStack');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>This object represents a segmented stack.  Memory can be allocated from this
stack using a  object.  Multiple
 objects may be created per
 but each  uses a single
.
<br><br>
For most use cases it's convenient to use the default thread-local
instance of , which is lazily instantiated on
the first call to the global function
.  Occasionally it may be useful
to have multiple independent stacks in one thread, in which case a
 can be created manually.
<br><br>

 is reference counted and has reference semantics.
When the last copy of a given instance goes out of scope, the memory
held by the  instance is released back to the
heap.  This cannot happen before memory allocated to a 
instance is released back to the stack, because a 
holds a copy of the  instance it uses.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>import</font> std.regionallocator;

<font color=blue>void</font> main() {
    fun1();
}

<font color=blue>void</font> fun1() {
    <font color=blue>auto</font> stack = <u>RegionAllocatorStack</u>(1_048_576, GCScan.no);
    fun2(stack);

    <font color=green>// At the end of fun1, the last copy of the RegionAllocatorStack
</font>    <font color=green>// instance pointed to by stack goes out of scope.  The memory
</font>    <font color=green>// held by stack is released back to the heap.
</font>}

<font color=blue>void</font> fun2(<u>RegionAllocatorStack</u> stack) {
    <font color=blue>auto</font> alloc = stack.newRegionAllocator();
    <font color=blue>auto</font> arr = alloc.newArray!(<font color=blue>double</font>[])(1_024);

    <font color=green>// At the end of fun2, the last copy of the RegionAllocator instance
</font>    <font color=green>// pointed to by alloc goes out of scope.  The memory used by arr
</font>    <font color=green>// is released back to stack.
</font>}
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">this(uint <span class="funcparam">segmentSize</span>, GCScan <span class="funcparam">shouldScan</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Create a new  with a given segment size in bytes.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">RegionAllocator 
<span class="currsymbol">newRegionAllocator</span>
<script>explorer.outline.addDecl('newRegionAllocator');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a new  region using this stack.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow @property @safe bool 
<span class="currsymbol">gcScanned</span>
<script>explorer.outline.addDecl('gcScanned');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Whether this stack is scanned by the garbage collector.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">nothrow @property @safe size_t 
<span class="currsymbol">threadLocalSegmentSize</span>
<script>explorer.outline.addDecl('threadLocalSegmentSize');</script>

();
<br>@property @safe size_t 
<span class="currsymbol">threadLocalSegmentSize</span>
<script>explorer.outline.addDecl('threadLocalSegmentSize');</script>

(size_t <span class="funcparam">newSize</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>These properties get and set the segment size of the default thread-local
 instance.  The default size is 4 megabytes.
The setter is only effective before the global function
 has been called for the first time in the current
thread.  Attempts to set this property after the first call to this
function from the current thread throw a .<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">nothrow @property @safe bool 
<span class="currsymbol">scanThreadLocalStack</span>
<script>explorer.outline.addDecl('scanThreadLocalStack');</script>

();
<br>@property @safe bool 
<span class="currsymbol">scanThreadLocalStack</span>
<script>explorer.outline.addDecl('scanThreadLocalStack');</script>

(bool <span class="funcparam">shouldScan</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>These properties determine whether the default thread-local
 instance is scanned by the garbage collector.
The default is no.  In most cases, scanning a stack this long-lived is not
recommended, as it will cause too many <b>false</b> pointers.  (See  for details.)
<br><br>
The setter is only effective before the global function
 has been called for the first time in the current
thread.  Attempts to set this property after the first call to this
function from the current thread throw a .<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">RegionAllocator</span>
<script>explorer.outline.addDecl('RegionAllocator');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>This struct provides an interface to the  functionality
and enforces scoped deletion.  A new instance using the thread-local
 instance is created using the global
 function.  A new instance using
an explicitly created  is created using
.
<br><br>
Each instance has reference semantics in that any copy will allocate from the
same memory.  When the last copy of an instance goes out of scope, all memory
allocated via that instance is freed.  Only the most recently created
still-existing  using a given 
may be used to allocate and free memory at any given time.  Deviations
from this model result in a  being thrown.
<br><br>

An uninitialized  (for example )
has semantics similar to a <b>null</b> pointer.  It may be assigned to or passed to
a function.  However, any attempt to call a method will result in a
 being thrown.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>void</font> foo() {
    <font color=blue>auto</font> alloc = newRegionAllocator();
    <font color=blue>auto</font> ptr1 = bar(alloc);
    <font color=blue>auto</font> ptr2 = alloc.allocate(42);

    <font color=green>// The last copy of the RegionAllocator object used to allocate ptr1
</font>    <font color=green>// and ptr2 is going out of scope here.  The memory pointed to by
</font>    <font color=green>// both ptr1 and ptr2 will be freed.
</font>}

<font color=blue>void</font>* bar(<u>RegionAllocator</u> alloc) {
    <font color=blue>auto</font> ret = alloc.allocate(42);

    <font color=blue>auto</font> alloc2 = newRegionAllocator();
    <font color=blue>auto</font> ptr3 = alloc2.allocate(42);

    <font color=green>// ptr3 was allocated using alloc2, which is going out of scope.
</font>    <font color=green>// Its memory will therefore be freed.  ret was allocated using alloc.
</font>    <font color=green>// A copy of this RegionAllocator is still alive in foo() after
</font>    <font color=green>// bar() executes.  Therefore, ret will not be freed on returning and
</font>    <font color=green>// is still valid after bar() returns.
</font>
    <font color=blue>return</font> ret;
}

<font color=blue>void</font>* thisIsSafe() {
    <font color=green>// This is safe because the two RegionAllocator objects being used
</font>    <font color=green>// are using two different RegionAllocatorStack objects.
</font>    <font color=blue>auto</font> alloc = newRegionAllocator();
    <font color=blue>auto</font> ptr1 = alloc.allocate(42);

    <font color=blue>auto</font> stack = RegionAllocatorStack(1_048_576, GCScan.no);
    <font color=blue>auto</font> alloc2 = stack.newRegionAllocator();

    <font color=blue>auto</font> ptr2 = alloc2.allocate(42);
    <font color=blue>auto</font> ptr3 = alloc.allocate(42);
}

<font color=blue>void</font>* dontDoThis() {
    <font color=blue>auto</font> alloc = newRegionAllocator();
    <font color=blue>auto</font> ptr1 = alloc.allocate(42);
    <font color=blue>auto</font> alloc2 = newRegionAllocator();

    <font color=green>// Error:  Allocating from a RegionAllocator instance other than the
</font>    <font color=green>// most recently created one that's still alive from a given stack.
</font>    <font color=blue>auto</font> ptr = alloc.allocate(42);
}

<font color=blue>void</font> uninitialized() {
    <u>RegionAllocator</u> alloc;
    <font color=blue>auto</font> ptr = alloc.allocate(42);  <font color=green>// Error:  alloc is not initialized.
</font>    <font color=blue>auto</font> alloc2 = alloc;  <font color=green>// Ok.  Both alloc, alloc2 are uninitialized.
</font>
    alloc2 = newRegionAllocator();
    <font color=blue>auto</font> ptr2 = alloc2.allocate(42);  <font color=green>// Ok.
</font>    <font color=blue>auto</font> ptr3 = alloc.allocate(42);  <font color=green>// Error:  alloc is still uninitialized.
</font>
    alloc = alloc2;
    <font color=blue>auto</font> ptr4 = alloc.allocate(42);  <font color=green>// Ok.
</font>}
</pre>

<br><br>
<b>Note:</b><br>
Allocations larger than  are handled as a special
case and fall back to allocating directly from the C heap.  These large
allocations are freed as if they were allocated on a 
when  or  is called or the last copy of a
 instance goes out of scope.  However, due to the extra
bookkeeping required, destroying a region (as happens when the last copy of
a  instance goes out of scope) will require time linear
instead of constant in the number of allocations for regions where these
large allocations are present.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void* 
<span class="currsymbol">allocate</span>
<script>explorer.outline.addDecl('allocate');</script>

(size_t <span class="funcparam">nBytes</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Allocates  bytes on the  used by this
     instance.  The last block allocated from this
     instance can be freed by calling
     or  or will be
    automatically freed when the last copy of this 
    instance goes out of scope.
<br><br>
Allocation requests larger than  are
    allocated directly on the C heap, are scanned by the GC iff
    the  instance that this object uses is scanned by
    the GC, and are freed according to the same rules as described above.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">freeLast</span>
<script>explorer.outline.addDecl('freeLast');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Frees the last block of memory allocated by the current
    .  Throws a  if
    this  is not the most recently created still-existing
     using its  instance.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">free</span>
<script>explorer.outline.addDecl('free');</script>

(void* <span class="funcparam">ptr</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Checks that  is a pointer to the block that would be freed by
     then calls .  Throws a
     if the pointer does not point to the
    block that would be freed by .<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">resize</span>
<script>explorer.outline.addDecl('resize');</script>

(const(void)* <span class="funcparam">ptr</span>, size_t <span class="funcparam">newSize</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Attempts to 
<span class="currsymbol">resize</span>
<script>explorer.outline.addDecl('resize');</script>

 a previously allocated block of memory in place.
    This is possible only if  points to the beginning of the last
    block allocated by this  instance and, in the
    case where  is greater than the old size, there is
    additional space in the segment that  was allocated from.
    Additionally, blocks larger than this 's segment size
    cannot be grown or shrunk.
<br><br>
<b>Returns:</b><br>
True if the block was successfully resized, <b>false</b> otherwise.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow @property @safe bool 
<span class="currsymbol">gcScanned</span>
<script>explorer.outline.addDecl('gcScanned');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns whether the  used by this
     instance is scanned by the garbage collector.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">auto 
<span class="currsymbol">newArray</span>
<script>explorer.outline.addDecl('newArray');</script>

(T, I...)(I <span class="funcparam">sizes</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Allocates an array of type .   may be a multidimensional
    array.  In this case sizes may be specified for any number of dimensions
    from 1 to the number in .
<br><br>
<b>Examples:</b><br>
<pre class="d_code">    <font color=blue>auto</font> alloc = newRegionAllocator();
    <font color=blue>double</font>[] arr = alloc.<u>newArray</u>!(<font color=blue>double</font>[])(100);
    <font color=blue>assert</font>(arr.length == 100);

    <font color=blue>double</font>[][] matrix = alloc.<u>newArray</u>!(<font color=blue>double</font>[][])(42, 31);
    <font color=blue>assert</font>(matrix.length == 42);
    <font color=blue>assert</font>(matrix[0].length == 31);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">auto 
<span class="currsymbol">uninitializedArray</span>
<script>explorer.outline.addDecl('uninitializedArray');</script>

(T, I...)(I <span class="funcparam">sizes</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as , except skips initialization of elements for
    performance reasons.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static size_t 
<span class="currsymbol">alignBytes</span>
<script>explorer.outline.addDecl('alignBytes');</script>

(size_t <span class="funcparam">nBytes</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the number of bytes to which an allocation of size <span class="funcparam">nBytes</span> is
    guaranteed to be aligned.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static pure nothrow size_t 
<span class="currsymbol">allocSize</span>
<script>explorer.outline.addDecl('allocSize');</script>

(size_t <span class="funcparam">nBytes</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the number of bytes used to satisfy an allocation request
    of .  Will return a value greater than or equal to
     to account for alignment overhead.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isAutomatic</span>
<script>explorer.outline.addDecl('isAutomatic');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>False because memory allocated by this allocator is not automatically
    reclaimed by the garbage collector.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isScoped</span>
<script>explorer.outline.addDecl('isScoped');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>True because, when the last last copy of a  instance
    goes out of scope, the memory it references is automatically freed.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">freeIsChecked</span>
<script>explorer.outline.addDecl('freeIsChecked');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>True because if memory is freed via  instead of 
    then the pointer is checked for validity.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">@property size_t 
<span class="currsymbol">segmentSize</span>
<script>explorer.outline.addDecl('segmentSize');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the segment size of the  used by this
    .<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">@property size_t 
<span class="currsymbol">segmentSlack</span>
<script>explorer.outline.addDecl('segmentSlack');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the maximum number of bytes that may be allocated in the
    current segment.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Unqual!(ElementType!(R))[] 
<span class="currsymbol">array</span>
<script>explorer.outline.addDecl('array');</script>

(R)(R <span class="funcparam">range</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Copies  to an 
<span class="currsymbol">array</span>
<script>explorer.outline.addDecl('array');</script>

.  The 
<span class="currsymbol">array</span>
<script>explorer.outline.addDecl('array');</script>

 will be located on the
     stack if any of the following conditions apply:
<br><br>
1.   is <b>false</b>.
<br><br>

    2.   is a builtin 
<span class="currsymbol">array</span>
<script>explorer.outline.addDecl('array');</script>

.  In this case  maintains pointers
        to all elements at least until  returns, preventing the
        elements from being freed by the garbage collector.  A similar
        assumption cannot be made for ranges other than builtin arrays.
<br><br>

    3.  The  instance used by this
         is scanned by the garbage collector.
<br><br>

    If none of these conditions is met, the 
<span class="currsymbol">array</span>
<script>explorer.outline.addDecl('array');</script>

 is returned on the C heap
    and  is called.  In either case, ,
    , or the last copy of this 
    instance going out of scope will free the 
<span class="currsymbol">array</span>
<script>explorer.outline.addDecl('array');</script>

 as if it had been
    allocated on the  stack.

<br><br>
<b>Rationale:</b><br>
The most common reason to call  on a builtin 
<span class="currsymbol">array</span>
<script>explorer.outline.addDecl('array');</script>

 is
                to modify its contents inside a function without affecting the
                caller's view.  In this case  is not modified and
                prevents the elements from being freed by the garbage
                collector.  Furthermore, if the copy returned does need
                to be scanned, the client can call  before
                modifying the original 
<span class="currsymbol">array</span>
<script>explorer.outline.addDecl('array');</script>

.

<br><br>
<b>Examples:</b><br>
<pre class="d_code">    <font color=blue>auto</font> alloc = newRegionAllocator();
    <font color=blue>auto</font> arr = alloc.<u>array</u>(iota(5));
    <font color=blue>assert</font>(arr == [0, 1, 2, 3, 4]);
</pre>
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">RegionAllocator 
<span class="currsymbol">newRegionAllocator</span>
<script>explorer.outline.addDecl('newRegionAllocator');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a new  that uses the default thread-local
 instance.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Dec 15 00:25:25 2011

		</td></tr>
	</table>
</div>
<script>
    explorer.packageExplorer.addModule("dstats.all");
	explorer.packageExplorer.addModule("dstats.alloc");
	explorer.packageExplorer.addModule("dstats.base");
	explorer.packageExplorer.addModule("dstats.cor");
	explorer.packageExplorer.addModule("dstats.distrib");
	explorer.packageExplorer.addModule("dstats.infotheory");
	explorer.packageExplorer.addModule("dstats.random");
	explorer.packageExplorer.addModule("dstats.pca");
	explorer.packageExplorer.addModule("dstats.kerneldensity");
	explorer.packageExplorer.addModule("dstats.regress");	
	explorer.packageExplorer.addModule("dstats.sort");
	explorer.packageExplorer.addModule("dstats.summary");
	explorer.packageExplorer.addModule("dstats.tests");
</script>
</body></html>


