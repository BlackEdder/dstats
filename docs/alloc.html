
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dstats.alloc</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dstats.alloc");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dstats.alloc</h1><!-- Generated by Ddoc from dstats\alloc.d -->
Stuff having to do with memory management.  Mostly TempAlloc and some data
 structure implementations that go with it.
<br><br>
<b>Author:</b><br>
David Simcha<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[] 
<span class="currsymbol">newVoid</span>
<script>explorer.outline.addDecl('newVoid');</script>

(T)(size_t <span class="funcparam">length</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a new array of type T w/o initializing elements.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">lengthVoid</span>
<script>explorer.outline.addDecl('lengthVoid');</script>

(T)(ref T[] <span class="funcparam">input</span>, size_t <span class="funcparam">newLength</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Lengthens an array w/o initializing new elements.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">appendDelOld</span>
<script>explorer.outline.addDecl('appendDelOld');</script>

(T, U)(ref T[] <span class="funcparam">to</span>, U <span class="funcparam">from</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Appends to an array, deleting the old array if it has to be realloced.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">TempAlloc</span>
<script>explorer.outline.addDecl('TempAlloc');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A struct to allocate memory in a strictly first-in last-out order for
 things like scratch space.  Technically, memory can safely escape the
 scope in which it was allocated.  However, this is a very bad idea
 unless being done within the private API of a class, struct or nested
 function, where it can be guaranteed that LIFO will not be violated.
<br><br>
Under the hood, this works by allocating large blocks (currently 4 MB)
 from the GC, and sub-allocating these as a stack.  Very large allocations
 (currently &gt; 4MB) are simply performed on the heap.  There are two ways to
 free memory:  Calling 
<span class="currsymbol">TempAlloc</span>
<script>explorer.outline.addDecl('TempAlloc');</script>

.free() frees the last allocated block.
 Calling 
<span class="currsymbol">TempAlloc</span>
<script>explorer.outline.addDecl('TempAlloc');</script>

.frameFree() frees all memory allocated since the last
 call to 
<span class="currsymbol">TempAlloc</span>
<script>explorer.outline.addDecl('TempAlloc');</script>

.frameInit().
<br><br>

 All allocations are aligned on 16-byte boundaries using padding, since on x86,
 16-byte alignment is necessary to make SSE2 work.  Note, however, that this
 is implemented based on the assumption that the GC allocates using 16-byte
 alignment (which appears to be <b>true</b> in druntime.)<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static State 
<span class="currsymbol">getState</span>
<script>explorer.outline.addDecl('getState');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Allows caller to cache the state class on the stack and pass it in as a
 parameter.  This is ugly, but results in a speed boost that can be
 significant in some cases because it avoids a thread-local storage
 lookup.  Also used internally.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static State 
<span class="currsymbol">frameInit</span>
<script>explorer.outline.addDecl('frameInit');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Initializes a frame, i.e. marks the current allocation position.
 Memory past the position at which this was last called will be
 freed when frameFree() is called.  Returns a reference to the
 State class in case the caller wants to cache it for speed.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static State 
<span class="currsymbol">frameInit</span>
<script>explorer.outline.addDecl('frameInit');</script>

(State <span class="funcparam">stateCopy</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as 
<span class="currsymbol">frameInit</span>
<script>explorer.outline.addDecl('frameInit');</script>

() but uses <span class="funcparam">stateCopy</span> cached on stack by caller
 to avoid a thread-local storage lookup.  Strictly a speed hack.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static void 
<span class="currsymbol">frameFree</span>
<script>explorer.outline.addDecl('frameFree');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Frees all memory allocated by TempAlloc since the last call to
 frameInit().<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static void 
<span class="currsymbol">frameFree</span>
<script>explorer.outline.addDecl('frameFree');</script>

(State <span class="funcparam">stateCopy</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as 
<span class="currsymbol">frameFree</span>
<script>explorer.outline.addDecl('frameFree');</script>

() but uses <span class="funcparam">stateCopy</span> cached on stack by caller
 to avoid a thread-local storage lookup.  Strictly a speed hack.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void* 
<span class="currsymbol">opCall</span>
<script>explorer.outline.addDecl('opCall');</script>

(T...)(T <span class="funcparam">args</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Purely a convenience overload, forwards arguments to TempAlloc.malloc().<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static void* 
<span class="currsymbol">malloc</span>
<script>explorer.outline.addDecl('malloc');</script>

(size_t <span class="funcparam">nbytes</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Allocates <span class="funcparam">nbytes</span> bytes on the TempAlloc stack.  NOT safe for real-time
 programming, since if there's not enough space on the current block,
 a new one will automatically be created.  Also, very large objects
 (currently over 4MB) will simply be heap-allocated.
<br><br>
<font color=red>BUGS:</font><br>
Memory allocated by TempAlloc is not scanned by the GC.
 This is necessary for performance and to avoid <b>false</b> pointer issues.
 Do not store the only reference to a GC-allocated object in
 TempAlloc-allocated memory.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static void* 
<span class="currsymbol">malloc</span>
<script>explorer.outline.addDecl('malloc');</script>

(size_t <span class="funcparam">nbytes</span>, State <span class="funcparam">stateCopy</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as 
<span class="currsymbol">malloc</span>
<script>explorer.outline.addDecl('malloc');</script>

() but uses <span class="funcparam">stateCopy</span> cached on stack by caller
 to avoid a thread-local storage lookup.  Strictly a speed hack.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static void 
<span class="currsymbol">free</span>
<script>explorer.outline.addDecl('free');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Frees the last piece of memory allocated by TempAlloc.  Since
 all memory must be allocated and freed in strict LIFO order,
 there's no need to pass a pointer in.  All bookkeeping for figuring
 out what to 
<span class="currsymbol">free</span>
<script>explorer.outline.addDecl('free');</script>

 is done internally.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static void 
<span class="currsymbol">free</span>
<script>explorer.outline.addDecl('free');</script>

(State <span class="funcparam">stateCopy</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as 
<span class="currsymbol">free</span>
<script>explorer.outline.addDecl('free');</script>

() but uses <span class="funcparam">stateCopy</span> cached on stack by caller
 to avoid a thread-local storage lookup.  Strictly a speed hack.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static @property size_t 
<span class="currsymbol">slack</span>
<script>explorer.outline.addDecl('slack');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns how many bytes are available in the current frame.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[] 
<span class="currsymbol">newStack</span>
<script>explorer.outline.addDecl('newStack');</script>

(T)(size_t <span class="funcparam">size</span>, TempAlloc.State <span class="funcparam">state</span> = null);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Allocates an array of type T and size size using TempAlloc.
 Note that appending to this array using the ~= operator,
 or enlarging it using the .length property, will result in
 undefined behavior.  This is because, if the array is located
 at the beginning of a TempAlloc block, the GC will think the
 capacity is as large as a TempAlloc block, and will overwrite
 adjacent TempAlloc-allocated data, instead of reallocating it.
<br><br>
<font color=red>BUGS:</font><br>
Do not store the only reference to a GC-allocated reference object
 in an array allocated by 
<span class="currsymbol">newStack</span>
<script>explorer.outline.addDecl('newStack');</script>

 because this memory is not
 scanned by the GC.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[0] 
<span class="currsymbol">stackCat</span>
<script>explorer.outline.addDecl('stackCat');</script>

(T...)(T <span class="funcparam">data</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>**Same as newStack(size_t) but uses stateCopy cached on stack by caller
Concatenate any number of arrays of the same type, placing results on
 the TempAlloc stack.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Unqual!(ElementType!(T))[] 
<span class="currsymbol">tempdup</span>
<script>explorer.outline.addDecl('tempdup');</script>

(T)(T <span class="funcparam">data</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a duplicate of a range for temporary use within a function in the
 best wsy that can be done safely.  If ElementType!(T) is a value type
 or T is an array, the results can safely be placed in TempAlloc because
 either it doesn't need to be scanned by the GC or there's guaranteed to be
 another reference to the contents somewhere. Otherwise, the results
 are placed on the GC heap.
<br><br>
This function is much faster if T has a length, but works even if it doesn't.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">immutable char[] 
<span class="currsymbol">newFrame</span>
<script>explorer.outline.addDecl('newFrame');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A string to mixin at the beginning of a scope, purely for
 convenience.  Initializes a TempAlloc frame using frameInit(),
 and inserts a scope statement to delete this frame at the end
 of the current scope.
<br><br>
Slower than calling free() manually when only a few pieces
 of memory will be allocated in the current scope, due to the
 extra bookkeeping involved.  Can be faster, however, when
 large amounts of allocations, such as arrays of arrays,
 are allocated, due to caching of data stored in thread-local
 storage.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">HashRange</span>
<script>explorer.outline.addDecl('HashRange');</script>

(K,S,bool vals = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Forward range struct for iterating over the keys or values of a
 StackHash or StackSet.  The lifetime of this object must not exceed that
 of the underlying StackHash or StackSet.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">popFront</span>
<script>explorer.outline.addDecl('popFront');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Unqual!(K) 
<span class="currsymbol">front</span>
<script>explorer.outline.addDecl('front');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">empty</span>
<script>explorer.outline.addDecl('empty');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">typeof(this) 
<span class="currsymbol">save</span>
<script>explorer.outline.addDecl('save');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">StackHash</span>
<script>explorer.outline.addDecl('StackHash');</script>

(K,V);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A hash table that allocates its memory on TempAlloc.  Good for building a
 temporary hash tables that will not escape the current scope.
<br><br>
To avoid TempAlloc memory leaks, use mixin(newFrame).

<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>mixin</font>(newFrame);  <font color=green>// To make sure all memory gets freed at end of scope.
</font> <font color=blue>auto</font> ss = <u>StackHash</u>!(<font color=blue>uint</font>)(5);
 <font color=blue>foreach</font>(i; 0..5) {
     ss[i]++;
 }
 <font color=blue>assert</font>(ss[3] == 1);
</pre>

<br><br>
<b>Warning:</b><br>
This implementation places removed nodes on an internal free list and
 recycles them, since there is no way to delete TempAlloc-allocated data
 in a non-LIFO order.  Therefore, you may not retain the address of a
 variable stored in a 
<span class="currsymbol">StackHash</span>
<script>explorer.outline.addDecl('StackHash');</script>

 after deleting it from the StachHash.
 For example, DO NOT do this:
<pre class="d_code"> SomeType* myPtr = &amp;(myStackHash[<font color=red>"foo"</font>]);
 myStackHash.remove(<font color=red>"foo"</font>);
 *myPtr = someValue;
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">
<span class="currsymbol">__ctor</span>
<script>explorer.outline.addDecl('__ctor');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Due to the nature of TempAlloc, you must specify on object creation
 the approximate number of elements your table will have.  Too large a
 number will waste space and incur poor cache performance.  Too low a
 number will make this struct perform like a linked list.  Generally,
 if you're building a table from some other range, some fraction of the
 size of that range is a good guess.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V 
<span class="currsymbol">opIndex</span>
<script>explorer.outline.addDecl('opIndex');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Index an element of the range.  If it does not exist, it will be created
 and initialized to V.init.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V 
<span class="currsymbol">opIndexAssign</span>
<script>explorer.outline.addDecl('opIndexAssign');</script>

(V <span class="funcparam">val</span>, K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V* 
<span class="currsymbol">opIn_r</span>
<script>explorer.outline.addDecl('opIn_r');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">HashRange!(K,StackHash!(K,V)) 
<span class="currsymbol">keys</span>
<script>explorer.outline.addDecl('keys');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a forward range to iterate over the 
<span class="currsymbol">keys</span>
<script>explorer.outline.addDecl('keys');</script>

 of this table.
 The lifetime of the HashRange must not exceed the lifetime of this
 StackHash.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">HashRange!(V,StackHash!(K,V),true) 
<span class="currsymbol">values</span>
<script>explorer.outline.addDecl('values');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a forward range to iterate over the 
<span class="currsymbol">values</span>
<script>explorer.outline.addDecl('values');</script>

 of this table.
 The lifetime of the HashRange must not exceed the lifetime of this
 StackHash.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V 
<span class="currsymbol">get</span>
<script>explorer.outline.addDecl('get');</script>

(K <span class="funcparam">key</span>, lazy V <span class="funcparam">defaultValue</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Attempt to look up a <span class="funcparam">key</span> and return a default value if the <span class="funcparam">key</span> is not
    present.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">StackSet</span>
<script>explorer.outline.addDecl('StackSet');</script>

(K);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A hash set that allocates its memory on TempAlloc.  Good for building a
 temporary set that will not escape the current scope.
<br><br>
To avoid TempAlloc memory leaks, use mixin(newFrame).

<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>mixin</font>(newFrame);  <font color=green>// To make sure all memory gets freed at end of scope.
</font> <font color=blue>auto</font> ss = <u>StackSet</u>!(<font color=blue>uint</font>)(5);
 <font color=blue>foreach</font>(i; 0..5) {
     ss.insert(i);
 }
 <font color=blue>assert</font>(3 <font color=blue>in</font> ss);
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">
<span class="currsymbol">__ctor</span>
<script>explorer.outline.addDecl('__ctor');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Due to the nature of TempAlloc, you must specify on object creation
 the approximate number of elements your set will have.  Too large a
 number will waste space and incur poor cache performance.  Too low a
 number will make this struct perform like a linked list.  Generally,
 if you're building a set from some other range, some fraction of the
 size of that range is a good guess.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">insert</span>
<script>explorer.outline.addDecl('insert');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">HashRange!(K,typeof(this)) 
<span class="currsymbol">elems</span>
<script>explorer.outline.addDecl('elems');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns a forward range of the elements of this struct.  The range's
 lifetime must not exceed the lifetime of this object.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">opIn_r</span>
<script>explorer.outline.addDecl('opIn_r');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">StackTree</span>
<script>explorer.outline.addDecl('StackTree');</script>

(T,alias key = "a",alias compFun = "a &lt; b");
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An AVL tree implementation on top of TempAlloc.  If elements are removed,
 they are stored on an internal free list and recycled when new elements
 are added to the tree.
<br><br>
Template paramters:
<br><br>

 T = The type to be stored in the tree.
<br><br>

 key = Function to access the key that what you're storing is to be compared
       on.
<br><br>

 compFun = The function for comparing keys.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>struct</font> StringNum {
     string someString;
     <font color=blue>uint</font> num;
 }

 <font color=green>// Create a StackTree of StringNums, sorted in descending order, using
</font> <font color=green>// someString for comparison.
</font> <font color=blue>auto</font> myTree = <u>StackTree</u>!(StringNum, <font color=red>"a.someString"</font>, <font color=red>"a &gt; b"</font>)();

 <font color=green>// Add some elements.
</font> myTree.insert( StringNum(<font color=red>"foo"</font>, 1));
 myTree.insert( StringNum(<font color=red>"bar"</font>, 2));
 myTree.insert( StringNum(<font color=red>"foo"</font>, 3));

 <font color=blue>assert</font>(myTree.find(<font color=red>"foo"</font>) == StringNum(<font color=red>"foo"</font>, 3));
 <font color=blue>assert</font>(myTree.find(<font color=red>"bar"</font>) == StringNum(<font color=red>"bar"</font>, 2));
</pre>

<br><br>
<b>Note:</b><br>
This tree supports a compile-time interface similar to StackSet
 and can be used as a finite set implementation.

<br><br>
<b>Warning:</b><br>
This implementation places removed nodes on an internal free list and
 recycles them, since there is no way to delete TempAlloc-allocated data
 in a non-LIFO order.  Therefore, you may not retain the address of a
 variable stored in a 
<span class="currsymbol">StackTree</span>
<script>explorer.outline.addDecl('StackTree');</script>

 after deleting it from the 
<span class="currsymbol">StackTree</span>
<script>explorer.outline.addDecl('StackTree');</script>

.
 For example, DO NOT do this:
<pre class="d_code"> SomeType* myPtr = <font color=red>"foo"</font> <font color=blue>in</font> myTree;
 myTree.remove(<font color=red>"foo"</font>);
 *myPtr = someValue;
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">typeof(this) 
<span class="currsymbol">opCall</span>
<script>explorer.outline.addDecl('opCall');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>De facto constructor.  Not using a "real" c'tor only because structs
 don't support default c'tors yet.  This must be called, or else you will
 get an access violation when you try to insert an element.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">insert</span>
<script>explorer.outline.addDecl('insert');</script>

(T <span class="funcparam">toInsert</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Insert an element.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

(U)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Remove an element from this tree.  The type of U is expected to be the
 type of the key that this tree is sorted on.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

(U <span class="funcparam">whatToRemove</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Remove an element from this tree.  The type of U is expected to be the
 type of the key that this tree is sorted on.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">find</span>
<script>explorer.outline.addDecl('find');</script>

(U)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Find an element and return it.  Throw an exception if it is not
 present.  U is expected to be the type of the key that this tree is
 sorted on.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T 
<span class="currsymbol">find</span>
<script>explorer.outline.addDecl('find');</script>

(U <span class="funcparam">whatToFind</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Find an element and return it.  Throw an exception if it is not
 present.  U is expected to be the type of the key that this tree is
 sorted on.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">opIn_r</span>
<script>explorer.outline.addDecl('opIn_r');</script>

(U)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Find an element and return a pointer to it, or <b>null</b> if not present.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T* 
<span class="currsymbol">opIn_r</span>
<script>explorer.outline.addDecl('opIn_r');</script>

(U <span class="funcparam">whatToFind</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Find an element and return a pointer to it, or <b>null</b> if not present.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">opApply</span>
<script>explorer.outline.addDecl('opApply');</script>

(int delegate(ref T) <span class="funcparam">dg</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Iterate over the elements of this tree in sorted order.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow @property size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Number of elements in the tree.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">TreeAaIter</span>
<script>explorer.outline.addDecl('TreeAaIter');</script>

(T,alias mapFun);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Struct that iterates over keys or values of a StackTreeAA.
<br><br>
<font color=red>BUGS:</font><br>
Uses opApply instead of the more flexible ranges, because I
 haven't figured out how to iterate efficiently and in sorted order over a
 tree without control of the stack.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">opApply</span>
<script>explorer.outline.addDecl('opApply');</script>

(int delegate(ref IterType) <span class="funcparam">dg</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">StackTreeAA</span>
<script>explorer.outline.addDecl('StackTreeAA');</script>

(K,V);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An associative array implementation based on StackTree.  Lookups and
 insertions are O(log N).  This is significantly slower in both theory and
 practice than StackHash, but you may want to use it if:
<br><br>
1.  You don't know the approximate size of the table you will be creating
     in advance.  Unlike StackHash, this AA implementation does not need
     to pre-allocate anything.
<br><br>

 2.  You care more about worst-case performance than average-case
     performance.
<br><br>

 3.  You have a good comparison function for your type, but not a good hash
     function.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V 
<span class="currsymbol">opIndex</span>
<script>explorer.outline.addDecl('opIndex');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Looks up <span class="funcparam">key</span> in the table, returns it by reference.  If it does not
 exist, it will be created and initialized to V.init.  This is handy,
 for example, when counting things with integer types.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V 
<span class="currsymbol">opIndexAssign</span>
<script>explorer.outline.addDecl('opIndexAssign');</script>

(V <span class="funcparam">val</span>, K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">V* 
<span class="currsymbol">opIn_r</span>
<script>explorer.outline.addDecl('opIn_r');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

(K <span class="funcparam">key</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">@property TreeAaIter!(typeof(tree),"a.key") 
<span class="currsymbol">keys</span>
<script>explorer.outline.addDecl('keys');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">@property TreeAaIter!(typeof(tree),getVal) 
<span class="currsymbol">values</span>
<script>explorer.outline.addDecl('values');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">opApply</span>
<script>explorer.outline.addDecl('opApply');</script>

(int delegate(ref Unqual!(K), ref Unqual!(V)) <span class="funcparam">dg</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Iterate over both the keys and values of this associative array.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Wed May 25 22:15:54 2011

		</td></tr>
	</table>
</div>
<script>
    explorer.packageExplorer.addModule("dstats.all");
	explorer.packageExplorer.addModule("dstats.alloc");
	explorer.packageExplorer.addModule("dstats.base");
	explorer.packageExplorer.addModule("dstats.cor");
	explorer.packageExplorer.addModule("dstats.distrib");
	explorer.packageExplorer.addModule("dstats.infotheory");
	explorer.packageExplorer.addModule("dstats.random");
	explorer.packageExplorer.addModule("dstats.pca");
	explorer.packageExplorer.addModule("dstats.kerneldensity");
	explorer.packageExplorer.addModule("dstats.regress");	
	explorer.packageExplorer.addModule("dstats.sort");
	explorer.packageExplorer.addModule("dstats.summary");
	explorer.packageExplorer.addModule("dstats.tests");
</script>
</body></html>


