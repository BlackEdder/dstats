
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dstats.regress</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dstats.regress");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dstats.regress</h1><!-- Generated by Ddoc from dstats\regress.d -->
A module for performing linear regression.  This module has an unusual
 interface, as it is range-based instead of matrix based. Values for
 independent variables are provided as either a tuple or a range of ranges.
 This means that one can use, for example, map, to fit high order models and
 lazily evaluate certain values.  (For details, see examples below.)
<br><br>
<b>Author:</b><br>
David Simcha<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">PowMap</span>
<script>explorer.outline.addDecl('PowMap');</script>

(ExpType,T) if (isForwardRange!(T));
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">PowMap!(ExpType,T) 
<span class="currsymbol">powMap</span>
<script>explorer.outline.addDecl('powMap');</script>

(ExpType, T)(T <span class="funcparam">range</span>, ExpType <span class="funcparam">exponent</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Maps a forward range to a power determined at runtime.  ExpType is the type
 of the exponent.  Using an int is faster than using a double, but obviously
 less flexible.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">RegressRes</span>
<script>explorer.outline.addDecl('RegressRes');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Struct that holds the results of a linear regression.  It's a plain old
 data struct.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">betas</span>
<script>explorer.outline.addDecl('betas');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The coefficients, one for each range in X.  These will be in the order
 that the X ranges were passed in.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">stdErr</span>
<script>explorer.outline.addDecl('stdErr');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The standard error terms of the X ranges passed in.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">lowerBound</span>
<script>explorer.outline.addDecl('lowerBound');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The lower confidence bounds of the beta terms, at the confidence level
 specificied.  (Default 0.95).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">upperBound</span>
<script>explorer.outline.addDecl('upperBound');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The upper confidence bounds of the beta terms, at the confidence level
 specificied.  (Default 0.95).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">p</span>
<script>explorer.outline.addDecl('p');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The P-value for the alternative that the corresponding beta value is
 different from zero against the <b>null</b> that it is equal to zero.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">R2</span>
<script>explorer.outline.addDecl('R2');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The coefficient of determination.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">adjustedR2</span>
<script>explorer.outline.addDecl('adjustedR2');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The adjusted coefficient of determination.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">residualError</span>
<script>explorer.outline.addDecl('residualError');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The root mean square of the residuals.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">overallP</span>
<script>explorer.outline.addDecl('overallP');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The P-value for the model as a whole.  Based on an F-statistic.  The
 <b>null</b> here is that the model has no predictive value, the alternative
 is that it does.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">string 
<span class="currsymbol">toString</span>
<script>explorer.outline.addDecl('toString');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Print out the results in the default format.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Residuals</span>
<script>explorer.outline.addDecl('Residuals');</script>

(F,U,T...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Forward Range for holding the residuals from a regression analysis.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Residuals!(F,U,T) 
<span class="currsymbol">residuals</span>
<script>explorer.outline.addDecl('residuals');</script>

(F, U, T...)(F[] <span class="funcparam">betas</span>, U <span class="funcparam">Y</span>, T <span class="funcparam">X</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given the beta coefficients from a linear regression, and X and Y values,
 returns a range that lazily computes the 
<span class="currsymbol">residuals</span>
<script>explorer.outline.addDecl('residuals');</script>

.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">linearRegressBeta</span>
<script>explorer.outline.addDecl('linearRegressBeta');</script>

(U, T...)(U <span class="funcparam">Y</span>, T <span class="funcparam">XIn</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Perform a linear regression and return just the beta values.  The advantages
to just returning the beta values are that it's faster and that each range
needs to be iterated over only once, and thus can be just an input range.
The beta values are returned such that the smallest index corresponds to
the leftmost element of X.  X can be either a tuple or a range of input
ranges.  Y must be an input range.
<br><br>
If, after all X variables are passed in, a numeric type is passed as the last
parameter, this is treated as a ridge parameter and ridge regression is
performed.  Ridge regression is a form of regression that penalizes the L2 norm
of the beta vector and therefore results in more parsimonious models.
However, it makes statistical inference such as that supported by
linearRegress() difficult to impossible.  Therefore, linearRegress() doesn't
support ridges.
<br><br>

If no ridge parameter is passed, or equivalently if the ridge parameter is
zero, then ordinary least squares regression is performed.

<br><br>
<b>Notes:</b><br>
The X ranges are traversed in lockstep, but the traversal is stopped
at the end of the shortest one.  Therefore, using infinite ranges is safe.
For example, using repeat(1) to get an intercept term works.

<br><br>
<b>References:</b><br>
<br><br>
<b>http:</b><br>
//www.mathworks.com/help/toolbox/stats/ridge.html
<br><br>

Venables, W. N. &amp; Ripley, B. D. (2002) Modern Applied Statistics with S.
Fourth Edition. Springer, New York. ISBN 0-387-95457-0
(This is the citation for the MASS R package.)

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>int</font>[] nBeers = [8,6,7,5,3,0,9];
<font color=blue>int</font>[] nCoffees = [3,6,2,4,3,6,8];
<font color=blue>int</font>[] musicVolume = [3,1,4,1,5,9,2];
<font color=blue>int</font>[] programmingSkill = [2,7,1,8,2,8,1];
<font color=blue>double</font>[] betas = <u>linearRegressBeta</u>(programmingSkill, repeat(1), nBeers, nCoffees,
    musicVolume, map!<font color=red>"a * a"</font>(musicVolume));

<font color=green>// Now throw in a ridge parameter of 2.5.
</font><font color=blue>double</font>[] ridgeBetas = <u>linearRegressBeta</u>(programmingSkill, repeat(1), nBeers,
    nCoffees, musicVolume, map!<font color=red>"a * a"</font>(musicVolume), 2.5);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">linearRegressBetaBuf</span>
<script>explorer.outline.addDecl('linearRegressBetaBuf');</script>

(U, TRidge...)(double[] <span class="funcparam">buf</span>, U <span class="funcparam">Y</span>, TRidge <span class="funcparam">XRidge</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as linearRegressBeta, but allows the user to specify a buffer for
the beta terms.  If the buffer is too short, a new one is allocated.
Otherwise, the results are returned in the user-provided buffer.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">RegressRes 
<span class="currsymbol">linearRegress</span>
<script>explorer.outline.addDecl('linearRegress');</script>

(U, TC...)(U <span class="funcparam">Y</span>, TC <span class="funcparam">input</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Perform a linear regression as in linearRegressBeta, but return a
RegressRes with useful stuff for statistical inference.  If the last element
of input is a real, this is used to specify the confidence intervals to
be calculated.  Otherwise, the default of 0.95 is used.  The rest of input
should be the elements of X.
<br><br>
When using this function, which provides several useful statistics useful
for inference, each range must be traversed twice.  This means:
<br><br>

1.  They have to be forward ranges, not input ranges.
<br><br>

2.  If you have a large amount of data and you're mapping it to some
    expensive function, you may want to do this eagerly instead of lazily.

<br><br>
<b>Notes:</b><br>
The X ranges are traversed in lockstep, but the traversal is stopped
at the end of the shortest one.  Therefore, using infinite ranges is safe.
For example, using repeat(1) to get an intercept term works.
<br><br>

If the confidence interval specified is exactly 0, this is treated as a
special case and confidence interval calculation is skipped.  This can speed
things up significantly and therefore can be useful in monte carlo and possibly
data mining contexts.

<br><br>
<font color=red>BUGS:</font><br>
The statistical tests performed in this function assume that an
intercept term is included in your regression model.  If no intercept term
is included, the P-values, confidence intervals and adjusted R^2 values
calculated by this function will be wrong.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>int</font>[] nBeers = [8,6,7,5,3,0,9];
<font color=blue>int</font>[] nCoffees = [3,6,2,4,3,6,8];
<font color=blue>int</font>[] musicVolume = [3,1,4,1,5,9,2];
<font color=blue>int</font>[] programmingSkill = [2,7,1,8,2,8,1];

<font color=green>// Using default confidence interval:
</font><font color=blue>auto</font> results = <u>linearRegress</u>(programmingSkill, repeat(1), nBeers, nCoffees,
    musicVolume, map!<font color=red>"a * a"</font>(musicVolume));

<font color=green>// Using user-specified confidence interval:
</font><font color=blue>auto</font> results = <u>linearRegress</u>(programmingSkill, repeat(1), nBeers, nCoffees,
    musicVolume, map!<font color=red>"a * a"</font>(musicVolume), 0.8675309);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">PolyFitRes</span>
<script>explorer.outline.addDecl('PolyFitRes');</script>

(T);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Struct returned by polyFit.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T 
<span class="currsymbol">X</span>
<script>explorer.outline.addDecl('X');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The array of PowMap ranges created by polyFit.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">RegressRes 
<span class="currsymbol">regressRes</span>
<script>explorer.outline.addDecl('regressRes');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The rest of the results.  This is alias this'd.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">polyFitBeta</span>
<script>explorer.outline.addDecl('polyFitBeta');</script>

(T, U)(U <span class="funcparam">Y</span>, T <span class="funcparam">X</span>, uint <span class="funcparam">N</span>, double <span class="funcparam">ridge</span> = 0);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Convenience function that takes a forward range X and a forward range Y,
 creates an array of PowMap structs for integer powers from 0 through N,
 and calls linearRegressBeta.
<br><br>
<b>Returns:</b><br>
An array of doubles.  The index of each element corresponds to
 the exponent.  For example, the X<sup>2</sup> term will have an index of
 2.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">polyFitBetaBuf</span>
<script>explorer.outline.addDecl('polyFitBetaBuf');</script>

(T, U)(double[] <span class="funcparam">buf</span>, U <span class="funcparam">Y</span>, T <span class="funcparam">X</span>, uint <span class="funcparam">N</span>, double <span class="funcparam">ridge</span> = 0);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as polyFitBeta, but allows the caller to provide an explicit buffer
 to return the coefficients in.  If it's too short, a new one will be
 allocated.  Otherwise, results will be returned in the user-provided buffer.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">PolyFitRes!(PowMap!(uint,T)[]) 
<span class="currsymbol">polyFit</span>
<script>explorer.outline.addDecl('polyFit');</script>

(T, U)(U <span class="funcparam">Y</span>, T <span class="funcparam">X</span>, uint <span class="funcparam">N</span>, double <span class="funcparam">confInt</span> = 0.95);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Convenience function that takes a forward range X and a forward range Y,
 creates an array of PowMap structs for integer powers 0 through N,
 and calls linearRegress.
<br><br>
<b>Returns:</b><br>
A PolyFitRes containing the array of PowMap structs created and
 a RegressRes.  The PolyFitRes is alias this'd to the RegressRes.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">linearRegressPenalized</span>
<script>explorer.outline.addDecl('linearRegressPenalized');</script>

(Y, X...)(Y <span class="funcparam">yIn</span>, X <span class="funcparam">xIn</span>, double <span class="funcparam">lasso</span>, double <span class="funcparam">ridge</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Performs lasso (L1) and/or ridge (L2) penalized linear regression.  Due to the
way the data is standardized, no intercept term should be included in x
(unlike linearRegress and linearRegressBeta).  The intercept coefficient is
implicitly included and returned in the first element of the returned array.
Usage is otherwise identical.
<br><br>
<b>Note:</b><br>
Setting lasso equal to zero is equivalent to performing ridge regression.
       This can also be done with linearRegressBeta.  However, the
       linearRegressBeta algorithm is optimized for memory efficiency and
       large samples.  This algorithm is optimized for large feature sets.

<br><br>
<b>Returns:</b><br>
The beta coefficients for the regression model.

<br><br>
<b>References:</b><br>
Friedman J, et al Pathwise coordinate optimization. Ann. Appl. Stat.
2007;2:302-332.
<br><br>

Goeman, J. J., L1 penalized estimation in the Cox proportional hazards model.
Biometrical Journal 52(1), 70{84.
<br><br>

Eilers, P., Boer, J., Van Ommen, G., Van Houwelingen, H. 2001 Classification of
microarray data with penalized logistic regression. Proceedings of SPIE.
Progress in Biomedical Optics and Images vol. 4266, pp. 187-198<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">logisticRegressBeta</span>
<script>explorer.outline.addDecl('logisticRegressBeta');</script>

(T, U...)(T <span class="funcparam">yIn</span>, U <span class="funcparam">xRidge</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Computes a logistic regression using a maximum likelihood estimator
and returns the beta coefficients.  This is a generalized linear model with
the link function f(XB) = 1 / (1 + exp(XB)). This is generally used to model
the probability that a binary Y variable is 1 given a set of X variables.
<br><br>
For the purpose of this function, Y variables are interpreted as Booleans,
regardless of their type.  X may be either a range of ranges or a tuple of
ranges.  However, note that unlike in linearRegress, they are copied to an
array if they are not random access ranges.  Note that each value is accessed
several times, so if your range is a map to something expensive, you may
want to evaluate it eagerly.
<br><br>

If the last parameter passed in is a numeric value instead of a range,
it is interpreted as a ridge parameter and ridge regression is performed.  This
penalizes the L2 norm of the beta vector (in a scaled space) and results
in more parsimonious models.  It limits the usefulness of inference techniques
(p-values, confidence intervals), however, and is therefore not offered
in logisticRegres().
<br><br>

If no ridge parameter is passed, or equivalenty if the ridge parameter is
zero, then ordinary maximum likelihood regression is performed.
<br><br>

Note that, while this implementation of ridge regression was tested against
the R Design Package implementation, it uses slightly different conventions
that make the results not comparable without transformation.  dstats uses a
biased estimate of the variance to scale the beta vector penalties, while
Design uses an unbiased estimate.  Furthermore, Design penalizes by 1/2 of the
L2 norm, whereas dstats penalizes by the L2 norm.  Therefore, if n is the
sample size, and lambda is the penalty used with dstats, the proper penalty
to use in Design to get the same results is 2 * (n - 1) * lambda / n.
<br><br>

Also note that, as in linearRegress, repeat(1) can be used for the intercept
term.

<br><br>
<b>Returns:</b><br>
The beta coefficients for the regression model.

<br><br>
<b>References:</b><br>
<br><br>
<b>http:</b><br>
//en.wikipedia.org/wiki/Logistic_regression

<br><br>
<b>http:</b><br>
//socserv.mcmaster.ca/jfox/Courses/UCLA/logistic-regression-notes.pdf
<br><br>

S. Le Cessie and J. C. Van Houwelingen.  Ridge Estimators in Logistic
Regression.  Journal of the Royal Statistical Society. Series C
(Applied Statistics), Vol. 41, No. 1(1992), pp. 191-201
<br><br>

Frank E Harrell Jr (2009). Design: Design Package. R package version 2.3-0.
<br><br>
<b>http:</b><br>
//CRAN.R-project.org/package=Design<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">LogisticRes</span>
<script>explorer.outline.addDecl('LogisticRes');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Plain old data struct to hold the results of a logistic regression.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">betas</span>
<script>explorer.outline.addDecl('betas');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The coefficients, one for each range in X.  These will be in the order
 that the X ranges were passed in.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">stdErr</span>
<script>explorer.outline.addDecl('stdErr');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The standard error terms of the X ranges passed in.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">lowerBound</span>
<script>explorer.outline.addDecl('lowerBound');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The Wald lower confidence bounds of the beta terms, at the confidence level
    specificied.  (Default 0.95).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">upperBound</span>
<script>explorer.outline.addDecl('upperBound');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The Wald upper confidence bounds of the beta terms, at the confidence level
    specificied.  (Default 0.95).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">p</span>
<script>explorer.outline.addDecl('p');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The P-value for the alternative that the corresponding beta value is
    different from zero against the <b>null</b> that it is equal to zero.  These
    are calculated using the Wald Test.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">nullLogLikelihood</span>
<script>explorer.outline.addDecl('nullLogLikelihood');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The log likelihood for the <b>null</b> model.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">logLikelihood</span>
<script>explorer.outline.addDecl('logLikelihood');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The log likelihood for the model fit.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow @property @safe double 
<span class="currsymbol">aic</span>
<script>explorer.outline.addDecl('aic');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Akaike Information Criterion, which is a complexity-penalized goodness-
    of-fit score, equal to 2 * k - 2 log(L) where L is the log likelihood and
    k is the number of parameters.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">overallP</span>
<script>explorer.outline.addDecl('overallP');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The P-value for the model as a whole, based on the likelihood ratio test.
    The <b>null</b> here is that the model has no predictive value, the alternative
    is that it does have predictive value.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">string 
<span class="currsymbol">toString</span>
<script>explorer.outline.addDecl('toString');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Print out the results in the default format.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">LogisticRes 
<span class="currsymbol">logisticRegress</span>
<script>explorer.outline.addDecl('logisticRegress');</script>

(T, V...)(T <span class="funcparam">yIn</span>, V <span class="funcparam">input</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Similar to logisticRegressBeta, but returns a LogisticRes with useful stuff for
statistical inference.  If the last element of input is a floating point
number instead of a range, it is used to specify the confidence interval
calculated.  Otherwise, the default of 0.95 is used.
<br><br>
<b>References:</b><br>
<br><br>
<b>http:</b><br>
//en.wikipedia.org/wiki/Wald_test
<br><br>
<b>http:</b><br>
//en.wikipedia.org/wiki/Akaike_information_criterion<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">pure nothrow @safe double 
<span class="currsymbol">logistic</span>
<script>explorer.outline.addDecl('logistic');</script>

(double <span class="funcparam">xb</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The 
<span class="currsymbol">logistic</span>
<script>explorer.outline.addDecl('logistic');</script>

 function used in 
<span class="currsymbol">logistic</span>
<script>explorer.outline.addDecl('logistic');</script>

 regression.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double[] 
<span class="currsymbol">logisticRegressPenalized</span>
<script>explorer.outline.addDecl('logisticRegressPenalized');</script>

(Y, X...)(Y <span class="funcparam">yIn</span>, X <span class="funcparam">xIn</span>, double <span class="funcparam">lasso</span>, double <span class="funcparam">ridge</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Performs lasso (L1) and/or ridge (L2) penalized logistic regression.  Due to the
way the data is standardized, no intercept term should be included in x
(unlike logisticRegress and logisticRegressBeta).  The intercept coefficient is
implicitly included and returned in the first element of the returned array.
Usage is otherwise identical.
<br><br>
<b>Note:</b><br>
Setting lasso equal to zero is equivalent to performing ridge regression.
       This can also be done with logisticRegressBeta.  However, the
       logisticRegressBeta algorithm is optimized for memory efficiency and
       large samples.  This algorithm is optimized for large feature sets.

<br><br>
<b>Returns:</b><br>
The beta coefficients for the regression model.

<br><br>
<b>References:</b><br>
Friedman J, et al Pathwise coordinate optimization. Ann. Appl. Stat.
2007;2:302-332.
<br><br>

Goeman, J. J., L1 penalized estimation in the Cox proportional hazards model.
Biometrical Journal 52(1), 70{84.
<br><br>

Eilers, P., Boer, J., Van Ommen, G., Van Houwelingen, H. 2001 Classification of
microarray data with penalized logistic regression. Proceedings of SPIE.
Progress in Biomedical Optics and Images vol. 4266, pp. 187-198<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Sun Nov  6 11:33:57 2011

		</td></tr>
	</table>
</div>
<script>
    explorer.packageExplorer.addModule("dstats.all");
	explorer.packageExplorer.addModule("dstats.alloc");
	explorer.packageExplorer.addModule("dstats.base");
	explorer.packageExplorer.addModule("dstats.cor");
	explorer.packageExplorer.addModule("dstats.distrib");
	explorer.packageExplorer.addModule("dstats.infotheory");
	explorer.packageExplorer.addModule("dstats.random");
	explorer.packageExplorer.addModule("dstats.pca");
	explorer.packageExplorer.addModule("dstats.kerneldensity");
	explorer.packageExplorer.addModule("dstats.regress");	
	explorer.packageExplorer.addModule("dstats.sort");
	explorer.packageExplorer.addModule("dstats.summary");
	explorer.packageExplorer.addModule("dstats.tests");
</script>
</body></html>


