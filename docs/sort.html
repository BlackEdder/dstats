
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dstats.sort</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dstats.sort");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dstats.sort</h1><!-- Generated by Ddoc from dstats\sort.d -->
A comprehensive sorting library for statistical functions.  Each function
takes N arguments, which are arrays or array-like objects, sorts the first
and sorts the rest in lockstep.  For merge and insertion 
<span class="currsymbol">sort</span>
<script>explorer.outline.addDecl('sort');</script>

, if the last
argument is a ulong*, increments the dereference of this ulong* by the bubble

<span class="currsymbol">sort</span>
<script>explorer.outline.addDecl('sort');</script>

 distance between the first argument and the sorted version of the first
argument.  This is useful for some statistical calculations.
<br><br>
All sorting functions have the precondition that all parallel input arrays
must have the same length.

<br><br>
<b>Notes:</b><br>
Comparison functions must be written such that compFun(x, x) == <b>false</b>.
For example, "a &lt; b" is good, "a &lt;= b" is not.
<br><br>

These functions are heavily optimized for sorting arrays of
ints and floats (by far the most common case when doing statistical
calculations).  In these cases, they can be several times faster than the
equivalent functions in std.algorithm.  Since sorting is extremely important
for non-parametric statistics, this results in important real-world
performance gains.  However, it comes at a price in terms of generality:
<br><br>

1.  They assume that what they are sorting is cheap to copy via normal
    assignment.
<br><br>

2.  They don't work at all with general ranges, only arrays and maybe
    ranges very similar to arrays.
<br><br>

3.  All tuning and micro-optimization is done with ints and floats, not
    classes, large structs, strings, etc.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> foo = [3, 1, 2, 4, 5].dup;
<font color=blue>auto</font> bar = [8, 6, 7, 5, 3].dup;
qsort(foo, bar);
<font color=blue>assert</font>(foo == [1, 2, 3, 4, 5]);
<font color=blue>assert</font>(bar == [6, 7, 8, 5, 3]);
<font color=blue>auto</font> baz = [1.0, 0, -1, -2, -3].dup;
mergeSort!(<font color=red>"a &gt; b"</font>)(bar, foo, baz);
<font color=blue>assert</font>(bar == [8, 7, 6, 5, 3]);
<font color=blue>assert</font>(foo == [3, 2, 1, 4, 5]);
<font color=blue>assert</font>(baz == [-1.0, 0, 1, -2, -3]);
</pre>

<br><br>
<b>Author:</b><br>
David Simcha<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[0] 
<span class="currsymbol">qsort</span>
<script>explorer.outline.addDecl('qsort');</script>

(alias compFun = "a &lt; b", T...)(T <span class="funcparam">data</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Quick sort.  Unstable, O(N log N) time average, worst
 case, O(log N) space, small constant term in time complexity.
<br><br>
In this implementation, the following steps are taken to avoid the
 O(N<sup>2</sup>) worst case of naive quick sorts:
<br><br>

 1.  At each recursion, the median of the first, middle and last elements of
     the array is used as the pivot.
<br><br>

 2.  To handle the case of few unique elements, the "Fit Pivot" technique
     previously decribed by Andrei Alexandrescu is used.  This allows
     reasonable performance with few unique elements, with zero overhead
     in other cases.
<br><br>

 3.  After a much larger than expected amount of recursion has occured,
     this function transitions to a heap sort.  This guarantees an O(N log N)
     worst case.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[0] 
<span class="currsymbol">mergeSort</span>
<script>explorer.outline.addDecl('mergeSort');</script>

(alias compFun = "a &lt; b", T...)(T <span class="funcparam">data</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Merge sort.  O(N log N) time, O(N) space, small constant.  Stable sort.
 If last argument is a ulong* instead of an array-like type,
 the dereference of the ulong* will be incremented by the bubble sort
 distance between the input array and the sorted version.  This is useful
 in some statistics functions such as Kendall's tau.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[0] 
<span class="currsymbol">mergeSortTemp</span>
<script>explorer.outline.addDecl('mergeSortTemp');</script>

(alias compFun = "a &lt; b", T...)(T <span class="funcparam">data</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Merge sort, allowing caller to provide a temp variable.  This allows
 recycling instead of repeated allocations.  If D is data, T is temp,
 and U is a ulong* for calculating bubble sort distance, this can be called
 as 
<span class="currsymbol">mergeSortTemp</span>
<script>explorer.outline.addDecl('mergeSortTemp');</script>

(D, D, D, T, T, T, U) or 
<span class="currsymbol">mergeSortTemp</span>
<script>explorer.outline.addDecl('mergeSortTemp');</script>

(D, D, D, T, T, T)
 where each D has a T of corresponding type.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>int</font>[] foo = [3, 1, 2, 4, 5].dup;
 <font color=blue>int</font>[] temp = <font color=blue>new</font> <font color=blue>uint</font>[5];
 <u>mergeSortTemp</u>!(<font color=red>"a &lt; b"</font>)(foo, temp);
 <font color=blue>assert</font>(foo == [1, 2, 3, 4, 5]); <font color=green>// The contents of temp will be undefined.
</font> foo = [3, 1, 2, 4, 5].dup;
 <font color=blue>real</font> bar = [3.14L, 15.9, 26.5, 35.8, 97.9];
 <font color=blue>real</font> temp2 = <font color=blue>new</font> <font color=blue>real</font>[5];
 <u>mergeSortTemp</u>(foo, bar, temp, temp2);
 <font color=blue>assert</font>(foo == [1, 2, 3, 4, 5]);
 <font color=blue>assert</font>(bar == [15.9L, 26.5, 3.14, 35.8, 97.9]);
 <font color=green>// The contents of both temp and temp2 will be undefined.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[0] 
<span class="currsymbol">mergeSortInPlace</span>
<script>explorer.outline.addDecl('mergeSortInPlace');</script>

(alias compFun = "a &lt; b", T...)(T <span class="funcparam">data</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>In-place merge sort, based on C++ STL's stable_sort().  O(N log<sup>2</sup> N)
 time complexity, O(1) space complexity, stable.  Much slower than plain
 old mergeSort(), so only use it if you really need the O(1) space.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[0] 
<span class="currsymbol">heapSort</span>
<script>explorer.outline.addDecl('heapSort');</script>

(alias compFun = "a &lt; b", T...)(T <span class="funcparam">data</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Heap sort.  Unstable, O(N log N) time average and worst case, O(1) space,
 large constant term in time complexity.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[0] 
<span class="currsymbol">insertionSort</span>
<script>explorer.outline.addDecl('insertionSort');</script>

(alias compFun = "a &lt; b", T...)(T <span class="funcparam">data</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Insertion sort.  O(N<sup>2</sup>) time worst, average case, O(1) space, VERY
 small constant, which is why it's useful for sorting small subarrays in
 divide and conquer algorithms.  If last argument is a ulong*, increments
 the dereference of this argument by the bubble sort distance between the
 input array and the sorted version of the input.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T 
<span class="currsymbol">quickSelect</span>
<script>explorer.outline.addDecl('quickSelect');</script>

(alias compFun = "a &lt; b", T)(T[] <span class="funcparam">data</span>, sizediff_t <span class="funcparam">k</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the kth largest/smallest element (depending on compFun, 0-indexed)
 in the input array in O(N) time.  Allocates memory, does not modify input
 array.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ElementType!(T[0]) 
<span class="currsymbol">partitionK</span>
<script>explorer.outline.addDecl('partitionK');</script>

(alias compFun = "a &lt; b", T...)(T <span class="funcparam">data</span>, ptrdiff_t <span class="funcparam">k</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Partitions the input data according to compFun, such that position k contains
 the kth largest/smallest element according to compFun.  For all elements e
 with indices &lt; k, !compFun(data[k], e) is guaranteed to be <b>true</b>.  For all
 elements e with indices &gt; k, !compFun(e, data[k]) is guaranteed to be <b>true</b>.
 For example, if compFun is "a &lt; b", all elements with indices &lt; k will be
 &lt;= data[k], and all elements with indices larger than k will be &gt;= k.
 Reorders any additional input arrays in lockstep.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>auto</font> foo = [3, 1, 5, 4, 2].dup;
 <font color=blue>auto</font> secondSmallest = <u>partitionK</u>(foo, 1);
 <font color=blue>assert</font>(secondSmallest == 2);
 <font color=blue>foreach</font>(elem; foo[0..1]) {
     <font color=blue>assert</font>(elem &lt;= foo[1]);
 }
 <font color=blue>foreach</font>(elem; foo[2..$]) {
     <font color=blue>assert</font>(elem &gt;= foo[1]);
 }
</pre>

<br><br>
<b>Returns:</b><br>
The kth element of the array.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">TopN</span>
<script>explorer.outline.addDecl('TopN');</script>

(T,alias compFun = "a &gt; b");
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a set of data points entered through the put function, this output range
 maintains the invariant that the top N according to compFun will be
 contained in the data structure.  Uses a heap internally, O(log N) insertion
 time.  Good for finding the largest/smallest N elements of a very large
 dataset that cannot be sorted quickly in its entirety, and may not even fit
 in memory. If less than N datapoints have been entered, all are contained in
 the structure.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> Random gen;
 gen.seed(unpredictableSeed);
 <font color=blue>uint</font>[] nums = seq(0U, 100U);
 <font color=blue>auto</font> less = <u>TopN</u>!(<font color=blue>uint</font>, <font color=red>"a &lt; b"</font>)(10);
 <font color=blue>auto</font> more = <u>TopN</u>!(<font color=blue>uint</font>, <font color=red>"a &gt; b"</font>)(10);
 randomShuffle(nums, gen);
 <font color=blue>foreach</font>(n; nums) {
     less.put(n);
     more.put(n);
 }
  <font color=blue>assert</font>(less.getSorted == [0U, 1,2,3,4,5,6,7,8,9]);
  <font color=blue>assert</font>(more.getSorted == [99U, 98, 97, 96, 95, 94, 93, 92, 91, 90]);
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">this(uint <span class="funcparam">ntop</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The variable <span class="funcparam">ntop</span> controls how many elements are retained.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">put</span>
<script>explorer.outline.addDecl('put');</script>

(T <span class="funcparam">elem</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Insert an element into the topN struct.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[] 
<span class="currsymbol">getElements</span>
<script>explorer.outline.addDecl('getElements');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Get the elements currently in the struct.  Returns a reference to
 internal state, elements will be in an arbitrary order.  Cheap.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[] 
<span class="currsymbol">getSorted</span>
<script>explorer.outline.addDecl('getSorted');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the elements sorted by compFun.  The array returned is a
 duplicate of the input array.  Not cheap.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Sun Nov  6 11:33:57 2011

		</td></tr>
	</table>
</div>
<script>
    explorer.packageExplorer.addModule("dstats.all");
	explorer.packageExplorer.addModule("dstats.alloc");
	explorer.packageExplorer.addModule("dstats.base");
	explorer.packageExplorer.addModule("dstats.cor");
	explorer.packageExplorer.addModule("dstats.distrib");
	explorer.packageExplorer.addModule("dstats.infotheory");
	explorer.packageExplorer.addModule("dstats.random");
	explorer.packageExplorer.addModule("dstats.pca");
	explorer.packageExplorer.addModule("dstats.kerneldensity");
	explorer.packageExplorer.addModule("dstats.regress");	
	explorer.packageExplorer.addModule("dstats.sort");
	explorer.packageExplorer.addModule("dstats.summary");
	explorer.packageExplorer.addModule("dstats.tests");
</script>
</body></html>


