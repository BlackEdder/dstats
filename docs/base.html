
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dstats.base</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dstats.base");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dstats.base</h1><!-- Generated by Ddoc from dstats\base.d -->
Relatively low-level primitives on which to build higher-level math/stat
 functionality.  Some are used internally, some are just things that may be
 useful to users of this library.  This module is starting to take on the
 appearance of a small utility library.
<br><br>
<b>Note:</b><br>
In several functions in this module that return arrays, the last
 parameter is an optional buffer for storing the return value.  If this
 parameter is ommitted or the buffer is not large enough, one will be
 allocated on the GC heap.

<br><br>
<b>Author:</b><br>
David Simcha<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">class 
<span class="currsymbol">DstatsArgumentException</span>
<script>explorer.outline.addDecl('DstatsArgumentException');</script>

: object.Exception;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>This is the exception that is thrown on invalid arguments to a dstats function.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">doubleInput</span>
<script>explorer.outline.addDecl('doubleInput');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Tests whether T is an input range whose elements can be implicitly
converted to doubles.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">doubleIterable</span>
<script>explorer.outline.addDecl('doubleIterable');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Tests whether T is iterable and has elements of a type implicitly
 convertible to double.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Tuple!(T) 
<span class="currsymbol">saveAll</span>
<script>explorer.outline.addDecl('saveAll');</script>

(T...)(T <span class="funcparam">args</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a tuple possibly containing forward ranges, returns a tuple where
save() has been called on all forward ranges.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Ret[] 
<span class="currsymbol">binCounts</span>
<script>explorer.outline.addDecl('binCounts');</script>

(Ret = uint, T)(T <span class="funcparam">data</span>, uint <span class="funcparam">nbin</span>, Ret[] <span class="funcparam">buf</span> = null);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Bins data into nbin equal width bins, indexed from
 0 to nbin - 1, with 0 being the smallest bin, etc.
 The values returned are the counts for each bin.
<br><br>
Works with any forward range with elements implicitly convertible to double.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Ret[] 
<span class="currsymbol">bin</span>
<script>explorer.outline.addDecl('bin');</script>

(Ret = ubyte, T)(T <span class="funcparam">data</span>, uint <span class="funcparam">nbin</span>, Ret[] <span class="funcparam">buf</span> = null);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Bins data into nbin equal width bins, indexed from
 0 to nbin - 1, with 0 being the smallest 
<span class="currsymbol">bin</span>
<script>explorer.outline.addDecl('bin');</script>

, etc.
 The values returned are the 
<span class="currsymbol">bin</span>
<script>explorer.outline.addDecl('bin');</script>

 index for each element.
<br><br>
Default return type is ubyte, because in the dstats.infotheory,
 entropy() and related functions specialize on ubytes, and become
 substandially faster.  However, if you're using more than 255 bins,
 you'll have to provide a different return type as a template parameter.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Ret[] 
<span class="currsymbol">frqBin</span>
<script>explorer.outline.addDecl('frqBin');</script>

(Ret = ubyte, T)(T <span class="funcparam">data</span>, uint <span class="funcparam">nbin</span>, Ret[] <span class="funcparam">buf</span> = null);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Bins data into nbin equal frequency bins, indexed from
 0 to nbin - 1, with 0 being the smallest bin, etc.
 The values returned are the bin index for each element.
<br><br>
Default return type is ubyte, because in the dstats.infotheory,
 entropy() and related functions specialize on ubytes, and become
 substandially faster.  However, if you're using more than 256 bins,
 you'll have to provide a different return type as a template parameter.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">CommonType!(T,U)[] 
<span class="currsymbol">seq</span>
<script>explorer.outline.addDecl('seq');</script>

(T, U, V = uint)(T <span class="funcparam">start</span>, U <span class="funcparam">end</span>, V <span class="funcparam">increment</span> = 1u);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Generates a sequence from [start..end] by increment.  Includes start,
 excludes end.  Does so eagerly as an array.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>auto</font> s = <u>seq</u>(0, 5);
 <font color=blue>assert</font>(s == [0, 1, 2, 3, 4]);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Ret[] 
<span class="currsymbol">rank</span>
<script>explorer.outline.addDecl('rank');</script>

(alias compFun = "a &lt; b", Ret = double, T)(T <span class="funcparam">input</span>, Ret[] <span class="funcparam">buf</span> = null);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given an input array, outputs an array containing the 
<span class="currsymbol">rank</span>
<script>explorer.outline.addDecl('rank');</script>

 from
 [1, input.length] corresponding to each element.  Ties are dealt with by
 averaging.  This function does not reorder the input range.
 Return type is float[] by default, but if you are sure you have no ties,
 ints can be used for efficiency (in which case ties will not be averaged),
 and if you need more precision when averaging ties, you can use double or
 real.
<br><br>
Works with any input range.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>uint</font>[] test = [3, 5, 3, 1, 2];
 <font color=blue>assert</font>(<u>rank</u>!(<font color=red>"a &lt; b"</font>, <font color=blue>float</font>)(test) == [3.5f, 5f, 3.5f, 1f, 2f]);
 <font color=blue>assert</font>(test == [3U, 5, 3, 1, 2]);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Ret[] 
<span class="currsymbol">rankSort</span>
<script>explorer.outline.addDecl('rankSort');</script>

(alias compFun = "a &lt; b", Ret = double, T)(T <span class="funcparam">input</span>, Ret[] <span class="funcparam">buf</span> = null);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as rank(), but also sorts the input range.
 The array returned will still be identical to that returned by rank(), i.e.
 the rank of each element will correspond to the ranks of the elements in the
 input array before sorting.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>uint</font>[] test = [3, 5, 3, 1, 2];
 <font color=blue>assert</font>(<u>rankSort</u>(test) == [3.5, 5, 3.5, 1.0, 2.0]);
 <font color=blue>assert</font>(test == [1U, 2, 3, 4, 5]);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint[ForeachType!(T)] 
<span class="currsymbol">frequency</span>
<script>explorer.outline.addDecl('frequency');</script>

(T)(T <span class="funcparam">input</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns an associative array of counts of every element in input.
 Works w/ any iterable.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>int</font>[] foo = [1,2,3,1,2,4];
 <font color=blue>uint</font>[<font color=blue>int</font>] frq = <u>frequency</u>(foo);
 <font color=blue>assert</font>(frq.length == 4);
 <font color=blue>assert</font>(frq[1] == 2);
 <font color=blue>assert</font>(frq[4] == 1);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ElementType!(V)[][ElementType!(C)] 
<span class="currsymbol">byCategory</span>
<script>explorer.outline.addDecl('byCategory');</script>

(V, C)(V <span class="funcparam">values</span>, C <span class="funcparam">categories</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a range of values and a range of categories, separates values
 by category.  This function also guarantees that the order within each
 category will be maintained.
<br><br>
<b>Note:</b><br>
While the general convention of this library is to try to avoid
 heap allocations whenever possible so that multithreaded code scales well and
 <b>false</b> pointers aren't an issue, this function allocates like crazy
 because there's basically no other way to implement it.  Don't use it in
 performance-critical multithreaded code.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>uint</font>[] values = [1,2,3,4,5,6,7,8];
 <font color=blue>bool</font>[] categories = [<font color=blue>false</font>, <font color=blue>false</font>, <font color=blue>false</font>, <font color=blue>false</font>, <font color=blue>true</font>, <font color=blue>true</font>, <font color=blue>true</font>, <font color=blue>true</font>];
 <font color=blue>auto</font> separated = <u>byCategory</u>(values, categories);
 <font color=blue>auto</font> tResult = studentsTTest(separated.values);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ElementType!(V)[][2] 
<span class="currsymbol">byCategory</span>
<script>explorer.outline.addDecl('byCategory');</script>

(V, C)(V <span class="funcparam">values</span>, C <span class="funcparam">categories</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Special case implementation for when ElementType!C is boolean.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">auroc</span>
<script>explorer.outline.addDecl('auroc');</script>

(R1, R2)(R1 <span class="funcparam">classATs</span>, R2 <span class="funcparam">classBTs</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Finds the area under the ROC curve (a curve with sensitivity on the Y-axis
 and 1 - specificity on the X-axis).  This is a useful metric for
 determining how well a test statistic discriminates between two classes.
 The following assumptions are made in this implementation:
<br><br>
1.  For some cutoff value c and test statistic T, your decision rule is of
     the form "Class A if T &gt; c, Class B if T &lt; c".
<br><br>

 2.  In the case of ties, i.e. if class A and class B both have an identical
     value, linear interpolation is used.  This is because changing the
     value of c infinitesimally will change both sensitivity and specificity
     in these cases.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">pure nothrow T 
<span class="currsymbol">sign</span>
<script>explorer.outline.addDecl('sign');</script>

(T)(T <span class="funcparam">num</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">logFactorial</span>
<script>explorer.outline.addDecl('logFactorial');</script>

(ulong <span class="funcparam">n</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">logNcomb</span>
<script>explorer.outline.addDecl('logNcomb');</script>

(ulong <span class="funcparam">n</span>, ulong <span class="funcparam">k</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Log of (<span class="funcparam">n</span> choose <span class="funcparam">k</span>).<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Perm</span>
<script>explorer.outline.addDecl('Perm');</script>

(T);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A struct that generates all possible permutations of a sequence.
<br><br>
<b>Notes:</b><br>
Permutations are output in undefined order.
<br><br>

The array returned by front is recycled across iterations.  To preserve
it across iterations, wrap this range using map!"a.dup" or
map!"a.idup".

<br><br>
<font color=red>BUGS:</font><br>
Only supports iterating over up to size_t.max permutations.
This means the max permutation length is 12 on 32-bit machines, or 20
on 64-bit.  This was a conscious tradeoff to allow this range to have a
length of type size_t, since iterating over such huge permutation spaces
would be insanely slow anyhow.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>double</font>[][] res;
<font color=blue>auto</font> perm = map!<font color=red>"a.dup"</font>(<u>Perm</u>!(<font color=blue>double</font>)([1.0, 2.0, 3.0][]));
<font color=blue>foreach</font>(p; perm) {
     res ~= p;
}

<font color=blue>auto</font> sorted = sort(res);
<font color=blue>assert</font>(sorted.canFind([1.0, 2.0, 3.0]));
<font color=blue>assert</font>(sorted.canFind([1.0, 3.0, 2.0]));
<font color=blue>assert</font>(sorted.canFind([2.0, 1.0, 3.0]));
<font color=blue>assert</font>(sorted.canFind([2.0, 3.0, 1.0]));
<font color=blue>assert</font>(sorted.canFind([3.0, 1.0, 2.0]));
<font color=blue>assert</font>(sorted.canFind([3.0, 2.0, 1.0]));
<font color=blue>assert</font>(sorted.length == 6);
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">this(U)(U <span class="funcparam">input</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Generate permutations from an input range.
 Create a duplicate of this sequence
 so that the original sequence is not modified.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const(T)[] 
<span class="currsymbol">front</span>
<script>explorer.outline.addDecl('front');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the current permutation.  The array is const because it is
    recycled across iterations and modifying it would destroy the state of
    the permutation generator.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">popFront</span>
<script>explorer.outline.addDecl('popFront');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Get the next permutation in the sequence.  This will overwrite the
    contents of the array returned by the last call to front.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">empty</span>
<script>explorer.outline.addDecl('empty');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The number of permutations left.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">typeof(this) 
<span class="currsymbol">save</span>
<script>explorer.outline.addDecl('save');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">auto 
<span class="currsymbol">perm</span>
<script>explorer.outline.addDecl('perm');</script>

(T...)(T <span class="funcparam">stuff</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Create a Perm struct from a range or of a set of bounds.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> p = <u>perm</u>([1,2,3]);  <font color=green>// All permutations of [1,2,3].
</font><font color=blue>auto</font> p = <u>perm</u>(5);  <font color=green>// All permutations of [0,1,2,3,4].
</font><font color=blue>auto</font> p = <u>perm</u>(-1, 2); <font color=green>// All permutations of [-1, 0, 1].
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">Comb</span>
<script>explorer.outline.addDecl('Comb');</script>

(T);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Generates every possible combination of r elements of the given sequence, or
array indices from zero to N, depending on which c'tor is called.  Uses
an input range interface.
<br><br>
<b>Note:</b><br>
The buffer that is returned by front is recycled across iterations.
To duplicate it instead, use map!"a.dup" or map!"a.idup".

<br><br>
<font color=red>BUGS:</font><br>
Only supports iterating over up to size_t.max combinations.
This was a conscious tradeoff to allow this range to have a
length of type size_t, since iterating over such huge combination spaces
would be insanely slow anyhow.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> comb1 = map!<font color=red>"a.dup"</font>(<u>Comb</u>!(<font color=blue>uint</font>)(5, 2));
<font color=blue>uint</font>[][] vals;
<font color=blue>foreach</font>(c; comb1) {
    vals ~= c;
}
<font color=blue>auto</font> sorted = sort(vals);
<font color=blue>assert</font>(sorted.canFind([0u,1]));
<font color=blue>assert</font>(sorted.canFind([0u,2]));
<font color=blue>assert</font>(sorted.canFind([0u,3]));
<font color=blue>assert</font>(sorted.canFind([0u,4]));
<font color=blue>assert</font>(sorted.canFind([1u,2]));
<font color=blue>assert</font>(sorted.canFind([1u,3]));
<font color=blue>assert</font>(sorted.canFind([1u,4]));
<font color=blue>assert</font>(sorted.canFind([2u,3]));
<font color=blue>assert</font>(sorted.canFind([2u,4]));
<font color=blue>assert</font>(sorted.canFind([3u,4]));
<font color=blue>assert</font>(sorted.length == 10);
</pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">this(uint <span class="funcparam">n</span>, uint <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Ctor to generate all possible combinations of array indices for a length <span class="funcparam">r</span>
    array.  This is a special-case optimization and is faster than simply
    using the other ctor to generate all length <span class="funcparam">r</span> combinations from
    seq(0, length).
<br><br>
For efficiency, uint is used instead of size_t since, on a 64-bit system,
    generating all possible combinations of an array bigger than uint.max
    wouldn't be feasible anyhow.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">this(T[] <span class="funcparam">array</span>, uint <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>General ctor.  <span class="funcparam">array</span> is a sequence from which to generate the
 combinations.  <span class="funcparam">r</span> is the length of the combinations to be generated.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const(T)[] 
<span class="currsymbol">front</span>
<script>explorer.outline.addDecl('front');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gets the current combination.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">popFront</span>
<script>explorer.outline.addDecl('popFront');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Advances to the next combination.  The array returned by front will be
    overwritten with the new results.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow bool 
<span class="currsymbol">empty</span>
<script>explorer.outline.addDecl('empty');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const pure nothrow size_t 
<span class="currsymbol">length</span>
<script>explorer.outline.addDecl('length');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">typeof(this) 
<span class="currsymbol">save</span>
<script>explorer.outline.addDecl('save');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">auto 
<span class="currsymbol">comb</span>
<script>explorer.outline.addDecl('comb');</script>

(T)(T <span class="funcparam">stuff</span>, uint <span class="funcparam">r</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Create a Comb struct from a range or of a set of bounds.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>auto</font> c1 = <u>comb</u>([1,2,3], 2);  <font color=green>// Any two elements from [1,2,3].
</font> <font color=blue>auto</font> c2 = <u>comb</u>(5, 3);  <font color=green>// Any three elements from [0,1,2,3,4].
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">ToNumericRange!(R) 
<span class="currsymbol">toNumericRange</span>
<script>explorer.outline.addDecl('toNumericRange');</script>

(R)(R <span class="funcparam">rangeIn</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Converts a range with arbitrary element types (usually strings) to a
 range of reals lazily.  Ignores any elements that could not be successfully
 converted.  Useful for creating an input range that can be used with this
 lib out of a File without having to read the whole file into an array first.
 The advantages to this over just using std.algorithm.map are that it's
 less typing and that it ignores non-convertible elements, such as blank
 lines.
<br><br>
If rangeIn is an inputRange, then the result of this function is an input
 range.  Otherwise, the result is a forward range.

<br><br>
<b>Note:</b><br>
The reason this struct doesn't have length or random access,
 even if this is supported by rangeIn, is because it has to be able to
 filter out non-convertible elements.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=green>// Perform a T-test to see whether the mean of the data being input as text
</font> <font color=green>// from stdin is different from zero.  This data might not even fit in memory
</font> <font color=green>// if it were read in eagerly.
</font>
 <font color=blue>auto</font> myRange = <u>toNumericRange</u>( stdin.byLine() );
 TestRes result = studentsTTest(myRange);
 writeln(result);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">ToNumericRange</span>
<script>explorer.outline.addDecl('ToNumericRange');</script>

(R) if (isInputRange!(R));
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Sun Nov  6 11:27:30 2011

		</td></tr>
	</table>
</div>
<script>
    explorer.packageExplorer.addModule("dstats.all");
	explorer.packageExplorer.addModule("dstats.alloc");
	explorer.packageExplorer.addModule("dstats.base");
	explorer.packageExplorer.addModule("dstats.cor");
	explorer.packageExplorer.addModule("dstats.distrib");
	explorer.packageExplorer.addModule("dstats.infotheory");
	explorer.packageExplorer.addModule("dstats.random");
	explorer.packageExplorer.addModule("dstats.pca");
	explorer.packageExplorer.addModule("dstats.kerneldensity");
	explorer.packageExplorer.addModule("dstats.regress");	
	explorer.packageExplorer.addModule("dstats.sort");
	explorer.packageExplorer.addModule("dstats.summary");
	explorer.packageExplorer.addModule("dstats.tests");
</script>
</body></html>


