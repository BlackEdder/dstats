
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>dstats.kerneldensity</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("dstats.kerneldensity");</script>
	<table class="content">
		<tr><td id="docbody"><h1>dstats.kerneldensity</h1><!-- Generated by Ddoc from dstats\kerneldensity.d -->
This module contains a small but growing library for performing kernel
 density estimation.
<br><br>
<b>Author:</b><br>
David Simcha<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">class 
<span class="currsymbol">KernelDensity1D</span>
<script>explorer.outline.addDecl('KernelDensity1D');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Estimates densities in the 1-dimensional case.  The 1-D case is special
 enough to be treated as a special case, since it's very common and enables
 some significant optimizations that are otherwise not feasible.
<br><br>
Under the hood, this works by binning the data into a large number of bins
 (currently 1,000), convolving it with the kernel function to smooth it, and
 then using linear interpolation to evaluate the density estimates.  This
 will produce results that are different from the textbook definition of
 kernel density estimation, but to an extent that's negligible in most cases.
 It also means that constructing this object is relatively expensive, but
 evaluating a density estimate can be done in O(1) time complexity afterwords.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">KernelDensity1D 
<span class="currsymbol">fromCallable</span>
<script>explorer.outline.addDecl('fromCallable');</script>

(C, R)(scope C <span class="funcparam">kernel</span>, R <span class="funcparam">range</span>, double <span class="funcparam">edgeBuffer</span> = (double).nan);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Construct a kernel density estimation object from a callable object.
 R must be a range of numeric types.  C must be a kernel function,
 delegate, or class or struct with overloaded opCall.  The kernel
 function is assumed to be symmetric about zero, to take its maximum
 value at zero and to be unimodal.
<br><br>
edgeBuffer determines how much space below and above the smallest and
 largest observed value will be allocated when doing the binning.
 Values less than reduce!min(range) - edgeBuffer or greater than
 reduce!max(range) + edgeBuffer will be assigned a density of zero.
 If this value is left at its default, it will be set to a value at which
 the kernel is somewhere between 1e-3 and 1e-4 times its value at zero.
<br><br>

 The bandwidth of the kernel is indirectly selected by parametrizing the
 kernel function.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>auto</font> randNums = randArray!rNorm(1_000, 0, 1);
 <font color=blue>auto</font> kernel = parametrize!normalPDF(0, 0.01);
 <font color=blue>auto</font> density = KernelDensity1D(kernel, randNums);
 writeln(normalPDF(1, 0, 1), <font color=red>"  "</font>, density(1)).  <font color=green>// Should be about the same.
</font></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">KernelDensity1D 
<span class="currsymbol">fromAlias</span>
<script>explorer.outline.addDecl('fromAlias');</script>

(alias kernel, R)(R <span class="funcparam">range</span>, double <span class="funcparam">edgeBuffer</span> = (double).nan);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Construct a kernel density estimator from an alias.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">KernelDensity1D 
<span class="currsymbol">fromDefaultKernel</span>
<script>explorer.outline.addDecl('fromDefaultKernel');</script>

(R)(R <span class="funcparam">range</span>, double <span class="funcparam">edgeBuffer</span> = (double).nan);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Construct a kernel density estimator using the default kernel, which is
 a Gaussian kernel with the Scott bandwidth.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const double 
<span class="currsymbol">opCall</span>
<script>explorer.outline.addDecl('opCall');</script>

(double <span class="funcparam">x</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Compute the probability density at a given point.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const double 
<span class="currsymbol">cdf</span>
<script>explorer.outline.addDecl('cdf');</script>

(double <span class="funcparam">x</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Compute the cumulative density, i.e. the integral from -infinity to <span class="funcparam">x</span>.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const double 
<span class="currsymbol">cdfr</span>
<script>explorer.outline.addDecl('cdfr');</script>

(double <span class="funcparam">x</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Compute the cumulative density from the rhs, i.e. the integral from
 <span class="funcparam">x</span> to infinity.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">scottBandwidth</span>
<script>explorer.outline.addDecl('scottBandwidth');</script>

(R)(R <span class="funcparam">data</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Uses Scott's Rule to select the bandwidth of the Gaussian kernel density
 estimator.  This is 1.06 * min(stdev(data), interquartileRange(data) / 1.34)
 N ^^ -0.2.  R must be a forward range of numeric types.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>immutable</font> bandwidth = <u>scottBandwidth</u>(data);
 <font color=blue>auto</font> kernel = parametrize!normalPDF(0, bandwidth);
 <font color=blue>auto</font> kde = KernelDensity1D(data, kernel);
</pre>

<br><br>
<b>References:</b><br>
Scott, D. W. (1992) Multivariate Density Estimation: Theory, Practice,
 and Visualization. Wiley.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">class 
<span class="currsymbol">KernelDensity</span>
<script>explorer.outline.addDecl('KernelDensity');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Construct an N-dimensional kernel density estimator.  This is done using
 the textbook definition of kernel density estimation, since the binning
 and convolving method used in the 1-D case would rapidly become
 unfeasible w.r.t. memory usage as dimensionality increased.
<br><br>
Eventually, a 2-D estimator might be added as another special case, but
 beyond 2-D, bin-and-convolute clearly isn't feasible.
<br><br>

 This class can be used for 1-D estimation instead of KernelDensity1D, and
 will work properly.  This is useful if:
<br><br>

 1.  You can't accept even the slightest deviation from the results that the
     textbook definition of kernel density estimation would produce.
<br><br>

 2.  You are only going to evaluate at a few points and want to avoid the
     up-front cost of the convolution used in the 1-D case.
<br><br>

 3.  You're using some weird kernel that doesn't meet the assumptions
     required for KernelDensity1D.<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const @property uint 
<span class="currsymbol">nDimensions</span>
<script>explorer.outline.addDecl('nDimensions');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the number of dimensions in the estimator.<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">KernelDensity 
<span class="currsymbol">fromCallable</span>
<script>explorer.outline.addDecl('fromCallable');</script>

(C, R...)(C <span class="funcparam">kernel</span>, R <span class="funcparam">ranges</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Construct a kernel density estimator from a kernel provided as a callable
 object (such as a function pointer, delegate, or class with overloaded
 opCall).  R must be either a range of ranges, multiple ranges passed in
 as variadic arguments, or a single range for the 1D case.  Each range
 represents the values of one variable in the joint distribution.
 kernel must accept either an array of doubles or the same number of
 arguments as the number of dimensions, and must return a floating point
 number.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=green>// Create an estimate of the density of the joint distribution of
</font> <font color=green>// hours sleep and programming skill.
</font> <font color=blue>auto</font> programmingSkill = [8,6,7,5,3,0,9];
 <font color=blue>auto</font> hoursSleep = [3,6,2,4,3,5,8];

 <font color=green>// Make a 2D Gaussian kernel function with bandwidth 0.5 in both
</font> <font color=green>// dimensions and covariance zero.
</font> <font color=blue>static</font> <font color=blue>double</font> myKernel(<font color=blue>double</font> x1, <font color=blue>double</font> x2) {
    <font color=blue>return</font> normalPDF(x1, 0, 0.5) * normalPDF(x2, 0, 0.5);
 }

 <font color=blue>auto</font> estimator = KernelDensity.<u>fromCallable</u>
     (&amp;myKernel, programmingSkill, hoursSleep);

 <font color=green>// Estimate the density at programming skill 1, 2 hours sleep.
</font> <font color=blue>auto</font> density = estimator(1, 2);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const double 
<span class="currsymbol">opCall</span>
<script>explorer.outline.addDecl('opCall');</script>

(double[] <span class="funcparam">x</span>...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Estimate the density at the point given by <span class="funcparam">x</span>.  The variables in X are
 provided in the same order as the ranges were provided for estimation.<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Sun Jan 29 12:41:19 2012

		</td></tr>
	</table>
</div>
<script>
    explorer.packageExplorer.addModule("dstats.all");
	explorer.packageExplorer.addModule("dstats.alloc");
	explorer.packageExplorer.addModule("dstats.base");
	explorer.packageExplorer.addModule("dstats.cor");
	explorer.packageExplorer.addModule("dstats.distrib");
	explorer.packageExplorer.addModule("dstats.infotheory");
	explorer.packageExplorer.addModule("dstats.random");
	explorer.packageExplorer.addModule("dstats.pca");
	explorer.packageExplorer.addModule("dstats.kerneldensity");
	explorer.packageExplorer.addModule("dstats.regress");	
	explorer.packageExplorer.addModule("dstats.sort");
	explorer.packageExplorer.addModule("dstats.summary");
	explorer.packageExplorer.addModule("dstats.tests");
</script>
</body></html>


